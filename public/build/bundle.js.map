{"version":3,"file":"bundle.js","sources":["../../node_modules/svelte/internal/index.mjs","../../node_modules/svelte/store/index.mjs","../../node_modules/chess.js/dist/chess.js","../../src/MoveViewer.svelte","../../src/Piece.svelte","../../src/Board.svelte","../../src/index.js"],"sourcesContent":["function noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\n// Adapted from https://github.com/then/is-promise/blob/master/index.js\n// Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE\nfunction is_promise(value) {\n    return !!value && (typeof value === 'object' || typeof value === 'function') && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nlet src_url_equal_anchor;\nfunction src_url_equal(element_src, url) {\n    if (!src_url_equal_anchor) {\n        src_url_equal_anchor = document.createElement('a');\n    }\n    src_url_equal_anchor.href = url;\n    return element_src === src_url_equal_anchor.href;\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction is_empty(obj) {\n    return Object.keys(obj).length === 0;\n}\nfunction validate_store(store, name) {\n    if (store != null && typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(store, ...callbacks) {\n    if (store == null) {\n        return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if ($$scope.dirty === undefined) {\n            return lets;\n        }\n        if (typeof lets === 'object') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\nfunction get_all_dirty_from_scope($$scope) {\n    if ($$scope.ctx.length > 32) {\n        const dirty = [];\n        const length = $$scope.ctx.length / 32;\n        for (let i = 0; i < length; i++) {\n            dirty[i] = -1;\n        }\n        return dirty;\n    }\n    return -1;\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nfunction compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props)\n        if (!keys.has(k) && k[0] !== '$')\n            rest[k] = props[k];\n    return rest;\n}\nfunction compute_slots(slots) {\n    const result = {};\n    for (const key in slots) {\n        result[key] = true;\n    }\n    return result;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value) {\n    store.set(value);\n    return ret;\n}\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\nfunction split_css_unit(value) {\n    const split = typeof value === 'string' && value.match(/^\\s*(-?[\\d.]+)([^\\s]*)\\s*$/);\n    return split ? [parseFloat(split[1]), split[2] || 'px'] : [value, 'px'];\n}\nconst contenteditable_truthy_values = ['', true, 1, 'true', 'contenteditable'];\n\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nfunction run_tasks(now) {\n    tasks.forEach(task => {\n        if (!task.c(now)) {\n            tasks.delete(task);\n            task.f();\n        }\n    });\n    if (tasks.size !== 0)\n        raf(run_tasks);\n}\n/**\n * For testing purposes only!\n */\nfunction clear_loops() {\n    tasks.clear();\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n    let task;\n    if (tasks.size === 0)\n        raf(run_tasks);\n    return {\n        promise: new Promise(fulfill => {\n            tasks.add(task = { c: callback, f: fulfill });\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\nconst globals = (typeof window !== 'undefined'\n    ? window\n    : typeof globalThis !== 'undefined'\n        ? globalThis\n        : global);\n\n/**\n * Resize observer singleton.\n * One listener per element only!\n * https://groups.google.com/a/chromium.org/g/blink-dev/c/z6ienONUb5A/m/F5-VcUZtBAAJ\n */\nclass ResizeObserverSingleton {\n    constructor(options) {\n        this.options = options;\n        this._listeners = 'WeakMap' in globals ? new WeakMap() : undefined;\n    }\n    observe(element, listener) {\n        this._listeners.set(element, listener);\n        this._getObserver().observe(element, this.options);\n        return () => {\n            this._listeners.delete(element);\n            this._observer.unobserve(element); // this line can probably be removed\n        };\n    }\n    _getObserver() {\n        var _a;\n        return (_a = this._observer) !== null && _a !== void 0 ? _a : (this._observer = new ResizeObserver((entries) => {\n            var _a;\n            for (const entry of entries) {\n                ResizeObserverSingleton.entries.set(entry.target, entry);\n                (_a = this._listeners.get(entry.target)) === null || _a === void 0 ? void 0 : _a(entry);\n            }\n        }));\n    }\n}\n// Needs to be written like this to pass the tree-shake-test\nResizeObserverSingleton.entries = 'WeakMap' in globals ? new WeakMap() : undefined;\n\n// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n// at the end of hydration without touching the remaining nodes.\nlet is_hydrating = false;\nfunction start_hydrating() {\n    is_hydrating = true;\n}\nfunction end_hydrating() {\n    is_hydrating = false;\n}\nfunction upper_bound(low, high, key, value) {\n    // Return first index of value larger than input value in the range [low, high)\n    while (low < high) {\n        const mid = low + ((high - low) >> 1);\n        if (key(mid) <= value) {\n            low = mid + 1;\n        }\n        else {\n            high = mid;\n        }\n    }\n    return low;\n}\nfunction init_hydrate(target) {\n    if (target.hydrate_init)\n        return;\n    target.hydrate_init = true;\n    // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n    let children = target.childNodes;\n    // If target is <head>, there may be children without claim_order\n    if (target.nodeName === 'HEAD') {\n        const myChildren = [];\n        for (let i = 0; i < children.length; i++) {\n            const node = children[i];\n            if (node.claim_order !== undefined) {\n                myChildren.push(node);\n            }\n        }\n        children = myChildren;\n    }\n    /*\n    * Reorder claimed children optimally.\n    * We can reorder claimed children optimally by finding the longest subsequence of\n    * nodes that are already claimed in order and only moving the rest. The longest\n    * subsequence of nodes that are claimed in order can be found by\n    * computing the longest increasing subsequence of .claim_order values.\n    *\n    * This algorithm is optimal in generating the least amount of reorder operations\n    * possible.\n    *\n    * Proof:\n    * We know that, given a set of reordering operations, the nodes that do not move\n    * always form an increasing subsequence, since they do not move among each other\n    * meaning that they must be already ordered among each other. Thus, the maximal\n    * set of nodes that do not move form a longest increasing subsequence.\n    */\n    // Compute longest increasing subsequence\n    // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n    const m = new Int32Array(children.length + 1);\n    // Predecessor indices + 1\n    const p = new Int32Array(children.length);\n    m[0] = -1;\n    let longest = 0;\n    for (let i = 0; i < children.length; i++) {\n        const current = children[i].claim_order;\n        // Find the largest subsequence length such that it ends in a value less than our current value\n        // upper_bound returns first greater value, so we subtract one\n        // with fast path for when we are on the current longest subsequence\n        const seqLen = ((longest > 0 && children[m[longest]].claim_order <= current) ? longest + 1 : upper_bound(1, longest, idx => children[m[idx]].claim_order, current)) - 1;\n        p[i] = m[seqLen] + 1;\n        const newLen = seqLen + 1;\n        // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n        m[newLen] = i;\n        longest = Math.max(newLen, longest);\n    }\n    // The longest increasing subsequence of nodes (initially reversed)\n    const lis = [];\n    // The rest of the nodes, nodes that will be moved\n    const toMove = [];\n    let last = children.length - 1;\n    for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n        lis.push(children[cur - 1]);\n        for (; last >= cur; last--) {\n            toMove.push(children[last]);\n        }\n        last--;\n    }\n    for (; last >= 0; last--) {\n        toMove.push(children[last]);\n    }\n    lis.reverse();\n    // We sort the nodes being moved to guarantee that their insertion order matches the claim order\n    toMove.sort((a, b) => a.claim_order - b.claim_order);\n    // Finally, we move the nodes\n    for (let i = 0, j = 0; i < toMove.length; i++) {\n        while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {\n            j++;\n        }\n        const anchor = j < lis.length ? lis[j] : null;\n        target.insertBefore(toMove[i], anchor);\n    }\n}\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n    const append_styles_to = get_root_for_style(target);\n    if (!append_styles_to.getElementById(style_sheet_id)) {\n        const style = element('style');\n        style.id = style_sheet_id;\n        style.textContent = styles;\n        append_stylesheet(append_styles_to, style);\n    }\n}\nfunction get_root_for_style(node) {\n    if (!node)\n        return document;\n    const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n    if (root && root.host) {\n        return root;\n    }\n    return node.ownerDocument;\n}\nfunction append_empty_stylesheet(node) {\n    const style_element = element('style');\n    append_stylesheet(get_root_for_style(node), style_element);\n    return style_element.sheet;\n}\nfunction append_stylesheet(node, style) {\n    append(node.head || node, style);\n    return style.sheet;\n}\nfunction append_hydration(target, node) {\n    if (is_hydrating) {\n        init_hydrate(target);\n        if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentNode !== target))) {\n            target.actual_end_child = target.firstChild;\n        }\n        // Skip nodes of undefined ordering\n        while ((target.actual_end_child !== null) && (target.actual_end_child.claim_order === undefined)) {\n            target.actual_end_child = target.actual_end_child.nextSibling;\n        }\n        if (node !== target.actual_end_child) {\n            // We only insert if the ordering of this node should be modified or the parent node is not target\n            if (node.claim_order !== undefined || node.parentNode !== target) {\n                target.insertBefore(node, target.actual_end_child);\n            }\n        }\n        else {\n            target.actual_end_child = node.nextSibling;\n        }\n    }\n    else if (node.parentNode !== target || node.nextSibling !== null) {\n        target.appendChild(node);\n    }\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction insert_hydration(target, node, anchor) {\n    if (is_hydrating && !anchor) {\n        append_hydration(target, node);\n    }\n    else if (node.parentNode !== target || node.nextSibling != anchor) {\n        target.insertBefore(node, anchor || null);\n    }\n}\nfunction detach(node) {\n    if (node.parentNode) {\n        node.parentNode.removeChild(node);\n    }\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (has_prop(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction comment(content) {\n    return document.createComment(content);\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_immediate_propagation(fn) {\n    return function (event) {\n        event.stopImmediatePropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction trusted(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.isTrusted)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\n/**\n * List of attributes that should always be set through the attr method,\n * because updating them through the property setter doesn't work reliably.\n * In the example of `width`/`height`, the problem is that the setter only\n * accepts numeric values, but the attribute can also be set to a string like `50%`.\n * If this list becomes too big, rethink this approach.\n */\nconst always_set_through_set_attribute = ['width', 'height'];\nfunction set_attributes(node, attributes) {\n    // @ts-ignore\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes) {\n        if (attributes[key] == null) {\n            node.removeAttribute(key);\n        }\n        else if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key === '__value') {\n            node.value = node[key] = attributes[key];\n        }\n        else if (descriptors[key] && descriptors[key].set && always_set_through_set_attribute.indexOf(key) === -1) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data_map(node, data_map) {\n    Object.keys(data_map).forEach((key) => {\n        set_custom_element_data(node, key, data_map[key]);\n    });\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction set_dynamic_element_data(tag) {\n    return (/-/.test(tag)) ? set_custom_element_data_map : set_attributes;\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group, __value, checked) {\n    const value = new Set();\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.add(group[i].__value);\n    }\n    if (!checked) {\n        value.delete(__value);\n    }\n    return Array.from(value);\n}\nfunction init_binding_group(group) {\n    let _inputs;\n    return {\n        /* push */ p(...inputs) {\n            _inputs = inputs;\n            _inputs.forEach(input => group.push(input));\n        },\n        /* remove */ r() {\n            _inputs.forEach(input => group.splice(group.indexOf(input), 1));\n        }\n    };\n}\nfunction init_binding_group_dynamic(group, indexes) {\n    let _group = get_binding_group(group);\n    let _inputs;\n    function get_binding_group(group) {\n        for (let i = 0; i < indexes.length; i++) {\n            group = group[indexes[i]] = group[indexes[i]] || [];\n        }\n        return group;\n    }\n    function push() {\n        _inputs.forEach(input => _group.push(input));\n    }\n    function remove() {\n        _inputs.forEach(input => _group.splice(_group.indexOf(input), 1));\n    }\n    return {\n        /* update */ u(new_indexes) {\n            indexes = new_indexes;\n            const new_group = get_binding_group(group);\n            if (new_group !== _group) {\n                remove();\n                _group = new_group;\n                push();\n            }\n        },\n        /* push */ p(...inputs) {\n            _inputs = inputs;\n            push();\n        },\n        /* remove */ r: remove\n    };\n}\nfunction to_number(value) {\n    return value === '' ? null : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction init_claim_info(nodes) {\n    if (nodes.claim_info === undefined) {\n        nodes.claim_info = { last_index: 0, total_claimed: 0 };\n    }\n}\nfunction claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {\n    // Try to find nodes in an order such that we lengthen the longest increasing subsequence\n    init_claim_info(nodes);\n    const resultNode = (() => {\n        // We first try to find an element after the previous one\n        for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                return node;\n            }\n        }\n        // Otherwise, we try to find one before\n        // We iterate in reverse so that we don't go too far back\n        for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                else if (replacement === undefined) {\n                    // Since we spliced before the last_index, we decrease it\n                    nodes.claim_info.last_index--;\n                }\n                return node;\n            }\n        }\n        // If we can't find any matching node, we create a new one\n        return createNode();\n    })();\n    resultNode.claim_order = nodes.claim_info.total_claimed;\n    nodes.claim_info.total_claimed += 1;\n    return resultNode;\n}\nfunction claim_element_base(nodes, name, attributes, create_element) {\n    return claim_node(nodes, (node) => node.nodeName === name, (node) => {\n        const remove = [];\n        for (let j = 0; j < node.attributes.length; j++) {\n            const attribute = node.attributes[j];\n            if (!attributes[attribute.name]) {\n                remove.push(attribute.name);\n            }\n        }\n        remove.forEach(v => node.removeAttribute(v));\n        return undefined;\n    }, () => create_element(name));\n}\nfunction claim_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, element);\n}\nfunction claim_svg_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, svg_element);\n}\nfunction claim_text(nodes, data) {\n    return claim_node(nodes, (node) => node.nodeType === 3, (node) => {\n        const dataStr = '' + data;\n        if (node.data.startsWith(dataStr)) {\n            if (node.data.length !== dataStr.length) {\n                return node.splitText(dataStr.length);\n            }\n        }\n        else {\n            node.data = dataStr;\n        }\n    }, () => text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n    );\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\nfunction claim_comment(nodes, data) {\n    return claim_node(nodes, (node) => node.nodeType === 8, (node) => {\n        node.data = '' + data;\n        return undefined;\n    }, () => comment(data), true);\n}\nfunction find_comment(nodes, text, start) {\n    for (let i = start; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {\n            return i;\n        }\n    }\n    return nodes.length;\n}\nfunction claim_html_tag(nodes, is_svg) {\n    // find html opening tag\n    const start_index = find_comment(nodes, 'HTML_TAG_START', 0);\n    const end_index = find_comment(nodes, 'HTML_TAG_END', start_index);\n    if (start_index === end_index) {\n        return new HtmlTagHydration(undefined, is_svg);\n    }\n    init_claim_info(nodes);\n    const html_tag_nodes = nodes.splice(start_index, end_index - start_index + 1);\n    detach(html_tag_nodes[0]);\n    detach(html_tag_nodes[html_tag_nodes.length - 1]);\n    const claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);\n    for (const n of claimed_nodes) {\n        n.claim_order = nodes.claim_info.total_claimed;\n        nodes.claim_info.total_claimed += 1;\n    }\n    return new HtmlTagHydration(claimed_nodes, is_svg);\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.data === data)\n        return;\n    text.data = data;\n}\nfunction set_data_contenteditable(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    text.data = data;\n}\nfunction set_data_maybe_contenteditable(text, data, attr_value) {\n    if (~contenteditable_truthy_values.indexOf(attr_value)) {\n        set_data_contenteditable(text, data);\n    }\n    else {\n        set_data(text, data);\n    }\n}\nfunction set_input_value(input, value) {\n    input.value = value == null ? '' : value;\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    if (value == null) {\n        node.style.removeProperty(key);\n    }\n    else {\n        node.style.setProperty(key, value, important ? 'important' : '');\n    }\n}\nfunction select_option(select, value, mounting) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n    if (!mounting || value !== undefined) {\n        select.selectedIndex = -1; // no option should be selected\n    }\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked');\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\nlet crossorigin;\nfunction is_crossorigin() {\n    if (crossorigin === undefined) {\n        crossorigin = false;\n        try {\n            if (typeof window !== 'undefined' && window.parent) {\n                void window.parent.document;\n            }\n        }\n        catch (error) {\n            crossorigin = true;\n        }\n    }\n    return crossorigin;\n}\nfunction add_iframe_resize_listener(node, fn) {\n    const computed_style = getComputedStyle(node);\n    if (computed_style.position === 'static') {\n        node.style.position = 'relative';\n    }\n    const iframe = element('iframe');\n    iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\n        'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');\n    iframe.setAttribute('aria-hidden', 'true');\n    iframe.tabIndex = -1;\n    const crossorigin = is_crossorigin();\n    let unsubscribe;\n    if (crossorigin) {\n        iframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\n        unsubscribe = listen(window, 'message', (event) => {\n            if (event.source === iframe.contentWindow)\n                fn();\n        });\n    }\n    else {\n        iframe.src = 'about:blank';\n        iframe.onload = () => {\n            unsubscribe = listen(iframe.contentWindow, 'resize', fn);\n            // make sure an initial resize event is fired _after_ the iframe is loaded (which is asynchronous)\n            // see https://github.com/sveltejs/svelte/issues/4233\n            fn();\n        };\n    }\n    append(node, iframe);\n    return () => {\n        if (crossorigin) {\n            unsubscribe();\n        }\n        else if (unsubscribe && iframe.contentWindow) {\n            unsubscribe();\n        }\n        detach(iframe);\n    };\n}\nconst resize_observer_content_box = /* @__PURE__ */ new ResizeObserverSingleton({ box: 'content-box' });\nconst resize_observer_border_box = /* @__PURE__ */ new ResizeObserverSingleton({ box: 'border-box' });\nconst resize_observer_device_pixel_content_box = /* @__PURE__ */ new ResizeObserverSingleton({ box: 'device-pixel-content-box' });\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, bubbles, cancelable, detail);\n    return e;\n}\nfunction query_selector_all(selector, parent = document.body) {\n    return Array.from(parent.querySelectorAll(selector));\n}\nfunction head_selector(nodeId, head) {\n    const result = [];\n    let started = 0;\n    for (const node of head.childNodes) {\n        if (node.nodeType === 8 /* comment node */) {\n            const comment = node.textContent.trim();\n            if (comment === `HEAD_${nodeId}_END`) {\n                started -= 1;\n                result.push(node);\n            }\n            else if (comment === `HEAD_${nodeId}_START`) {\n                started += 1;\n                result.push(node);\n            }\n        }\n        else if (started > 0) {\n            result.push(node);\n        }\n    }\n    return result;\n}\nclass HtmlTag {\n    constructor(is_svg = false) {\n        this.is_svg = false;\n        this.is_svg = is_svg;\n        this.e = this.n = null;\n    }\n    c(html) {\n        this.h(html);\n    }\n    m(html, target, anchor = null) {\n        if (!this.e) {\n            if (this.is_svg)\n                this.e = svg_element(target.nodeName);\n            /** #7364  target for <template> may be provided as #document-fragment(11) */\n            else\n                this.e = element((target.nodeType === 11 ? 'TEMPLATE' : target.nodeName));\n            this.t = target.tagName !== 'TEMPLATE' ? target : target.content;\n            this.c(html);\n        }\n        this.i(anchor);\n    }\n    h(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.nodeName === 'TEMPLATE' ? this.e.content.childNodes : this.e.childNodes);\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(this.t, this.n[i], anchor);\n        }\n    }\n    p(html) {\n        this.d();\n        this.h(html);\n        this.i(this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\nclass HtmlTagHydration extends HtmlTag {\n    constructor(claimed_nodes, is_svg = false) {\n        super(is_svg);\n        this.e = this.n = null;\n        this.l = claimed_nodes;\n    }\n    c(html) {\n        if (this.l) {\n            this.n = this.l;\n        }\n        else {\n            super.c(html);\n        }\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert_hydration(this.t, this.n[i], anchor);\n        }\n    }\n}\nfunction attribute_to_object(attributes) {\n    const result = {};\n    for (const attribute of attributes) {\n        result[attribute.name] = attribute.value;\n    }\n    return result;\n}\nfunction get_custom_elements_slots(element) {\n    const result = {};\n    element.childNodes.forEach((node) => {\n        result[node.slot || 'default'] = true;\n    });\n    return result;\n}\nfunction construct_svelte_component(component, props) {\n    return new component(props);\n}\n\n// we need to store the information for multiple documents because a Svelte application could also contain iframes\n// https://github.com/sveltejs/svelte/issues/3624\nconst managed_styles = new Map();\nlet active = 0;\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_style_information(doc, node) {\n    const info = { stylesheet: append_empty_stylesheet(node), rules: {} };\n    managed_styles.set(doc, info);\n    return info;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    const doc = get_root_for_style(node);\n    const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);\n    if (!rules[name]) {\n        rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    const previous = (node.style.animation || '').split(', ');\n    const next = previous.filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    );\n    const deleted = previous.length - next.length;\n    if (deleted) {\n        node.style.animation = next.join(', ');\n        active -= deleted;\n        if (!active)\n            clear_rules();\n    }\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        managed_styles.forEach(info => {\n            const { ownerNode } = info.stylesheet;\n            // there is no ownerNode if it runs on jsdom.\n            if (ownerNode)\n                detach(ownerNode);\n        });\n        managed_styles.clear();\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error('Function called outside component initialization');\n    return current_component;\n}\n/**\n * Schedules a callback to run immediately before the component is updated after any state change.\n *\n * The first time the callback runs will be before the initial `onMount`\n *\n * https://svelte.dev/docs#run-time-svelte-beforeupdate\n */\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\n/**\n * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.\n * It must be called during the component's initialisation (but doesn't need to live *inside* the component;\n * it can be called from an external module).\n *\n * `onMount` does not run inside a [server-side component](/docs#run-time-server-side-component-api).\n *\n * https://svelte.dev/docs#run-time-svelte-onmount\n */\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\n/**\n * Schedules a callback to run immediately after the component has been updated.\n *\n * The first time the callback runs will be after the initial `onMount`\n */\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\n/**\n * Schedules a callback to run immediately before the component is unmounted.\n *\n * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the\n * only one that runs inside a server-side component.\n *\n * https://svelte.dev/docs#run-time-svelte-ondestroy\n */\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\n/**\n * Creates an event dispatcher that can be used to dispatch [component events](/docs#template-syntax-component-directives-on-eventname).\n * Event dispatchers are functions that can take two arguments: `name` and `detail`.\n *\n * Component events created with `createEventDispatcher` create a\n * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).\n * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).\n * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)\n * property and can contain any type of data.\n *\n * https://svelte.dev/docs#run-time-svelte-createeventdispatcher\n */\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail, { cancelable = false } = {}) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail, { cancelable });\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n            return !event.defaultPrevented;\n        }\n        return true;\n    };\n}\n/**\n * Associates an arbitrary `context` object with the current component and the specified `key`\n * and returns that object. The context is then available to children of the component\n * (including slotted content) with `getContext`.\n *\n * Like lifecycle functions, this must be called during component initialisation.\n *\n * https://svelte.dev/docs#run-time-svelte-setcontext\n */\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n    return context;\n}\n/**\n * Retrieves the context that belongs to the closest parent component with the specified `key`.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs#run-time-svelte-getcontext\n */\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\n/**\n * Retrieves the whole context map that belongs to the closest parent component.\n * Must be called during component initialisation. Useful, for example, if you\n * programmatically create a component and want to pass the existing context to it.\n *\n * https://svelte.dev/docs#run-time-svelte-getallcontexts\n */\nfunction getAllContexts() {\n    return get_current_component().$$.context;\n}\n/**\n * Checks whether a given `key` has been set in the context of a parent component.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs#run-time-svelte-hascontext\n */\nfunction hasContext(key) {\n    return get_current_component().$$.context.has(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        // @ts-ignore\n        callbacks.slice().forEach(fn => fn.call(this, event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nlet render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = /* @__PURE__ */ Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\n// flush() calls callbacks in this order:\n// 1. All beforeUpdate callbacks, in order: parents before children\n// 2. All bind:this callbacks, in reverse order: children before parents.\n// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT\n//    for afterUpdates called during the initial onMount, which are called in\n//    reverse order: children before parents.\n// Since callbacks might update component values, which could trigger another\n// call to flush(), the following steps guard against this:\n// 1. During beforeUpdate, any updated components will be added to the\n//    dirty_components array and will cause a reentrant call to flush(). Because\n//    the flush index is kept outside the function, the reentrant call will pick\n//    up where the earlier call left off and go through all dirty components. The\n//    current_component value is saved and restored so that the reentrant call will\n//    not interfere with the \"parent\" flush() call.\n// 2. bind:this callbacks cannot trigger new flush() calls.\n// 3. During afterUpdate, any updated components will NOT have their afterUpdate\n//    callback called a second time; the seen_callbacks set, outside the flush()\n//    function, guarantees this behavior.\nconst seen_callbacks = new Set();\nlet flushidx = 0; // Do *not* move this inside the flush() function\nfunction flush() {\n    // Do not reenter flush while dirty components are updated, as this can\n    // result in an infinite loop. Instead, let the inner flush handle it.\n    // Reentrancy is ok afterwards for bindings etc.\n    if (flushidx !== 0) {\n        return;\n    }\n    const saved_component = current_component;\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        try {\n            while (flushidx < dirty_components.length) {\n                const component = dirty_components[flushidx];\n                flushidx++;\n                set_current_component(component);\n                update(component.$$);\n            }\n        }\n        catch (e) {\n            // reset dirty state to not end up in a deadlocked state and then rethrow\n            dirty_components.length = 0;\n            flushidx = 0;\n            throw e;\n        }\n        set_current_component(null);\n        dirty_components.length = 0;\n        flushidx = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    seen_callbacks.clear();\n    set_current_component(saved_component);\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n/**\n * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.\n */\nfunction flush_render_callbacks(fns) {\n    const filtered = [];\n    const targets = [];\n    render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n    targets.forEach((c) => c());\n    render_callbacks = filtered;\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n    else if (callback) {\n        callback();\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    const options = { direction: 'in' };\n    let config = fn(node, params, options);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, 'start'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, 'end');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            started = true;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config(options);\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    const options = { direction: 'out' };\n    let config = fn(node, params, options);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, 'start'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, 'end');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config(options);\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    const options = { direction: 'both' };\n    let config = fn(node, params, options);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = (program.b - t);\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program || pending_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro — we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro — needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config(options);\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = value;\n        let child_ctx = info.ctx;\n        if (key !== undefined) {\n            child_ctx = child_ctx.slice();\n            child_ctx[key] = value;\n        }\n        const block = type && (info.current = type)(child_ctx);\n        let needs_flush = false;\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            if (info.blocks[i] === block) {\n                                info.blocks[i] = null;\n                            }\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            needs_flush = true;\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n        if (needs_flush) {\n            flush();\n        }\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n            if (!info.hasCatch) {\n                throw error;\n            }\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = promise;\n    }\n}\nfunction update_await_block_branch(info, ctx, dirty) {\n    const child_ctx = ctx.slice();\n    const { resolved } = info;\n    if (info.current === info.then) {\n        child_ctx[info.value] = resolved;\n    }\n    if (info.current === info.catch) {\n        child_ctx[info.error] = resolved;\n    }\n    info.block.p(child_ctx, dirty);\n}\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    const updates = [];\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            // defer updates until all the DOM shuffling is done\n            updates.push(() => block.p(child_ctx, dirty));\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next);\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    run_all(updates);\n    return new_blocks;\n}\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n    const keys = new Set();\n    for (let i = 0; i < list.length; i++) {\n        const key = get_key(get_context(ctx, list, i));\n        if (keys.has(key)) {\n            throw new Error('Cannot have duplicate keys in a keyed each');\n        }\n        keys.add(key);\n    }\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\nconst _boolean_attributes = [\n    'allowfullscreen',\n    'allowpaymentrequest',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'hidden',\n    'inert',\n    'ismap',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected'\n];\n/**\n * List of HTML boolean attributes (e.g. `<input disabled>`).\n * Source: https://html.spec.whatwg.org/multipage/indices.html\n */\nconst boolean_attributes = new Set([..._boolean_attributes]);\n\n/** regex of all html void element names */\nconst void_element_names = /^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;\nfunction is_void(name) {\n    return void_element_names.test(name) || name.toLowerCase() === '!doctype';\n}\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, attrs_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (attrs_to_add) {\n        const classes_to_add = attrs_to_add.classes;\n        const styles_to_add = attrs_to_add.styles;\n        if (classes_to_add) {\n            if (attributes.class == null) {\n                attributes.class = classes_to_add;\n            }\n            else {\n                attributes.class += ' ' + classes_to_add;\n            }\n        }\n        if (styles_to_add) {\n            if (attributes.style == null) {\n                attributes.style = style_object_to_string(styles_to_add);\n            }\n            else {\n                attributes.style = style_object_to_string(merge_ssr_styles(attributes.style, styles_to_add));\n            }\n        }\n    }\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += ' ' + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += ' ' + name;\n        }\n        else if (value != null) {\n            str += ` ${name}=\"${value}\"`;\n        }\n    });\n    return str;\n}\nfunction merge_ssr_styles(style_attribute, style_directive) {\n    const style_object = {};\n    for (const individual_style of style_attribute.split(';')) {\n        const colon_index = individual_style.indexOf(':');\n        const name = individual_style.slice(0, colon_index).trim();\n        const value = individual_style.slice(colon_index + 1).trim();\n        if (!name)\n            continue;\n        style_object[name] = value;\n    }\n    for (const name in style_directive) {\n        const value = style_directive[name];\n        if (value) {\n            style_object[name] = value;\n        }\n        else {\n            delete style_object[name];\n        }\n    }\n    return style_object;\n}\nconst ATTR_REGEX = /[&\"]/g;\nconst CONTENT_REGEX = /[&<]/g;\n/**\n * Note: this method is performance sensitive and has been optimized\n * https://github.com/sveltejs/svelte/pull/5701\n */\nfunction escape(value, is_attr = false) {\n    const str = String(value);\n    const pattern = is_attr ? ATTR_REGEX : CONTENT_REGEX;\n    pattern.lastIndex = 0;\n    let escaped = '';\n    let last = 0;\n    while (pattern.test(str)) {\n        const i = pattern.lastIndex - 1;\n        const ch = str[i];\n        escaped += str.substring(last, i) + (ch === '&' ? '&amp;' : (ch === '\"' ? '&quot;' : '&lt;'));\n        last = i + 1;\n    }\n    return escaped + str.substring(last);\n}\nfunction escape_attribute_value(value) {\n    // keep booleans, null, and undefined for the sake of `spread`\n    const should_escape = typeof value === 'string' || (value && typeof value === 'object');\n    return should_escape ? escape(value, true) : value;\n}\nfunction escape_object(obj) {\n    const result = {};\n    for (const key in obj) {\n        result[key] = escape_attribute_value(obj[key]);\n    }\n    return result;\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules. Otherwise you may need to fix a <${name}>.`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots, context) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(context || (parent_component ? parent_component.$$.context : [])),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, $$slots, context);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return '';\n    const assignment = (boolean && value === true) ? '' : `=\"${escape(value, true)}\"`;\n    return ` ${name}${assignment}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class=\"${classes}\"` : '';\n}\nfunction style_object_to_string(style_object) {\n    return Object.keys(style_object)\n        .filter(key => style_object[key])\n        .map(key => `${key}: ${escape_attribute_value(style_object[key])};`)\n        .join(' ');\n}\nfunction add_styles(style_object) {\n    const styles = style_object_to_string(style_object);\n    return styles ? ` style=\"${styles}\"` : '';\n}\n\nfunction bind(component, name, callback) {\n    const index = component.$$.props[name];\n    if (index !== undefined) {\n        component.$$.bound[index] = callback;\n        callback(component.$$.ctx[index]);\n    }\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor, customElement) {\n    const { fragment, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    if (!customElement) {\n        // onMount happens before the initial afterUpdate\n        add_render_callback(() => {\n            const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n            // if the component was destroyed immediately\n            // it will update the `$$.on_destroy` reference to `null`.\n            // the destructured on_destroy may still reference to the old array\n            if (component.$$.on_destroy) {\n                component.$$.on_destroy.push(...new_on_destroy);\n            }\n            else {\n                // Edge case - component was destroyed immediately,\n                // most likely as a result of a binding initialising\n                run_all(new_on_destroy);\n            }\n            component.$$.on_mount = [];\n        });\n    }\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        flush_render_callbacks($$.after_update);\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: [],\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        on_disconnect: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n        // everything else\n        callbacks: blank_object(),\n        dirty,\n        skip_bound: false,\n        root: options.target || parent_component.$$.root\n    };\n    append_styles && append_styles($$.root);\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, options.props || {}, (i, ret, ...rest) => {\n            const value = rest.length ? rest[0] : ret;\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if (!$$.skip_bound && $$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            start_hydrating();\n            const nodes = children(options.target);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(nodes);\n            nodes.forEach(detach);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor, options.customElement);\n        end_hydrating();\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === 'function') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            const { on_mount } = this.$$;\n            this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        disconnectedCallback() {\n            run_all(this.$$.on_disconnect);\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            if (!is_function(callback)) {\n                return noop;\n            }\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    };\n}\n/**\n * Base class for Svelte components. Used when dev=false.\n */\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        if (!is_function(callback)) {\n            return noop;\n        }\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n            this.$$.skip_bound = true;\n            this.$$set($$props);\n            this.$$.skip_bound = false;\n        }\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.59.1' }, detail), { bubbles: true }));\n}\nfunction append_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append(target, node);\n}\nfunction append_hydration_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append_hydration(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction insert_hydration_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert_hydration(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev('SvelteDOMRemove', { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation, has_stop_immediate_propagation) {\n    const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push('preventDefault');\n    if (has_stop_propagation)\n        modifiers.push('stopPropagation');\n    if (has_stop_immediate_propagation)\n        modifiers.push('stopImmediatePropagation');\n    dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });\n    else\n        dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev('SvelteDOMSetProperty', { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev('SvelteDOMSetDataset', { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = '' + data;\n    if (text.data === data)\n        return;\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\n    text.data = data;\n}\nfunction set_data_contenteditable_dev(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\n    text.data = data;\n}\nfunction set_data_maybe_contenteditable_dev(text, data, attr_value) {\n    if (~contenteditable_truthy_values.indexOf(attr_value)) {\n        set_data_contenteditable_dev(text, data);\n    }\n    else {\n        set_data_dev(text, data);\n    }\n}\nfunction validate_each_argument(arg) {\n    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {\n        let msg = '{#each} only iterates over array-like objects.';\n        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {\n            msg += ' You can use a spread to convert this iterable into an array.';\n        }\n        throw new Error(msg);\n    }\n}\nfunction validate_slots(name, slot, keys) {\n    for (const slot_key of Object.keys(slot)) {\n        if (!~keys.indexOf(slot_key)) {\n            console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n        }\n    }\n}\nfunction validate_dynamic_element(tag) {\n    const is_string = typeof tag === 'string';\n    if (tag && !is_string) {\n        throw new Error('<svelte:element> expects \"this\" attribute to be a string.');\n    }\n}\nfunction validate_void_dynamic_element(tag) {\n    if (tag && is_void(tag)) {\n        console.warn(`<svelte:element this=\"${tag}\"> is self-closing and cannot have content.`);\n    }\n}\nfunction construct_svelte_component_dev(component, props) {\n    const error_message = 'this={...} of <svelte:component> should specify a Svelte component.';\n    try {\n        const instance = new component(props);\n        if (!instance.$$ || !instance.$set || !instance.$on || !instance.$destroy) {\n            throw new Error(error_message);\n        }\n        return instance;\n    }\n    catch (err) {\n        const { message } = err;\n        if (typeof message === 'string' && message.indexOf('is not a constructor') !== -1) {\n            throw new Error(error_message);\n        }\n        else {\n            throw err;\n        }\n    }\n}\n/**\n * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n */\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(\"'target' is a required option\");\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn('Component was already destroyed'); // eslint-disable-line no-console\n        };\n    }\n    $capture_state() { }\n    $inject_state() { }\n}\n/**\n * Base class to create strongly typed Svelte components.\n * This only exists for typing purposes and should be used in `.d.ts` files.\n *\n * ### Example:\n *\n * You have component library on npm called `component-library`, from which\n * you export a component called `MyComponent`. For Svelte+TypeScript users,\n * you want to provide typings. Therefore you create a `index.d.ts`:\n * ```ts\n * import { SvelteComponentTyped } from \"svelte\";\n * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}\n * ```\n * Typing this makes it possible for IDEs like VS Code with the Svelte extension\n * to provide intellisense and to use the component like this in a Svelte file\n * with TypeScript:\n * ```svelte\n * <script lang=\"ts\">\n * \timport { MyComponent } from \"component-library\";\n * </script>\n * <MyComponent foo={'bar'} />\n * ```\n *\n * #### Why not make this part of `SvelteComponent(Dev)`?\n * Because\n * ```ts\n * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}\n * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;\n * ```\n * will throw a type error, so we need to separate the more strictly typed class.\n */\nclass SvelteComponentTyped extends SvelteComponentDev {\n    constructor(options) {\n        super(options);\n    }\n}\nfunction loop_guard(timeout) {\n    const start = Date.now();\n    return () => {\n        if (Date.now() - start > timeout) {\n            throw new Error('Infinite loop detected');\n        }\n    };\n}\n\nexport { HtmlTag, HtmlTagHydration, ResizeObserverSingleton, SvelteComponent, SvelteComponentDev, SvelteComponentTyped, SvelteElement, action_destroyer, add_attribute, add_classes, add_flush_callback, add_iframe_resize_listener, add_location, add_render_callback, add_styles, add_transform, afterUpdate, append, append_dev, append_empty_stylesheet, append_hydration, append_hydration_dev, append_styles, assign, attr, attr_dev, attribute_to_object, beforeUpdate, bind, binding_callbacks, blank_object, bubble, check_outros, children, claim_comment, claim_component, claim_element, claim_html_tag, claim_space, claim_svg_element, claim_text, clear_loops, comment, component_subscribe, compute_rest_props, compute_slots, construct_svelte_component, construct_svelte_component_dev, contenteditable_truthy_values, createEventDispatcher, create_animation, create_bidirectional_transition, create_component, create_in_transition, create_out_transition, create_slot, create_ssr_component, current_component, custom_event, dataset_dev, debug, destroy_block, destroy_component, destroy_each, detach, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element, element_is, empty, end_hydrating, escape, escape_attribute_value, escape_object, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, flush_render_callbacks, getAllContexts, getContext, get_all_dirty_from_scope, get_binding_group_value, get_current_component, get_custom_elements_slots, get_root_for_style, get_slot_changes, get_spread_object, get_spread_update, get_store_value, globals, group_outros, handle_promise, hasContext, has_prop, head_selector, identity, init, init_binding_group, init_binding_group_dynamic, insert, insert_dev, insert_hydration, insert_hydration_dev, intros, invalid_attribute_name_character, is_client, is_crossorigin, is_empty, is_function, is_promise, is_void, listen, listen_dev, loop, loop_guard, merge_ssr_styles, missing_component, mount_component, noop, not_equal, now, null_to_empty, object_without_properties, onDestroy, onMount, once, outro_and_destroy_block, prevent_default, prop_dev, query_selector_all, raf, resize_observer_border_box, resize_observer_content_box, resize_observer_device_pixel_content_box, run, run_all, safe_not_equal, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_custom_element_data_map, set_data, set_data_contenteditable, set_data_contenteditable_dev, set_data_dev, set_data_maybe_contenteditable, set_data_maybe_contenteditable_dev, set_dynamic_element_data, set_input_type, set_input_value, set_now, set_raf, set_store_value, set_style, set_svg_attributes, space, split_css_unit, spread, src_url_equal, start_hydrating, stop_immediate_propagation, stop_propagation, subscribe, svg_element, text, tick, time_ranges_to_array, to_number, toggle_class, transition_in, transition_out, trusted, update_await_block_branch, update_keyed_each, update_slot, update_slot_base, validate_component, validate_dynamic_element, validate_each_argument, validate_each_keys, validate_slots, validate_store, validate_void_dynamic_element, xlink_attr };\n","import { noop, safe_not_equal, subscribe, run_all, is_function } from '../internal/index.mjs';\nexport { get_store_value as get } from '../internal/index.mjs';\n\nconst subscriber_queue = [];\n/**\n * Creates a `Readable` store that allows reading by subscription.\n * @param value initial value\n * @param {StartStopNotifier} [start]\n */\nfunction readable(value, start) {\n    return {\n        subscribe: writable(value, start).subscribe\n    };\n}\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n * @param {*=}value initial value\n * @param {StartStopNotifier=} start\n */\nfunction writable(value, start = noop) {\n    let stop;\n    const subscribers = new Set();\n    function set(new_value) {\n        if (safe_not_equal(value, new_value)) {\n            value = new_value;\n            if (stop) { // store is ready\n                const run_queue = !subscriber_queue.length;\n                for (const subscriber of subscribers) {\n                    subscriber[1]();\n                    subscriber_queue.push(subscriber, value);\n                }\n                if (run_queue) {\n                    for (let i = 0; i < subscriber_queue.length; i += 2) {\n                        subscriber_queue[i][0](subscriber_queue[i + 1]);\n                    }\n                    subscriber_queue.length = 0;\n                }\n            }\n        }\n    }\n    function update(fn) {\n        set(fn(value));\n    }\n    function subscribe(run, invalidate = noop) {\n        const subscriber = [run, invalidate];\n        subscribers.add(subscriber);\n        if (subscribers.size === 1) {\n            stop = start(set) || noop;\n        }\n        run(value);\n        return () => {\n            subscribers.delete(subscriber);\n            if (subscribers.size === 0 && stop) {\n                stop();\n                stop = null;\n            }\n        };\n    }\n    return { set, update, subscribe };\n}\nfunction derived(stores, fn, initial_value) {\n    const single = !Array.isArray(stores);\n    const stores_array = single\n        ? [stores]\n        : stores;\n    const auto = fn.length < 2;\n    return readable(initial_value, (set) => {\n        let started = false;\n        const values = [];\n        let pending = 0;\n        let cleanup = noop;\n        const sync = () => {\n            if (pending) {\n                return;\n            }\n            cleanup();\n            const result = fn(single ? values[0] : values, set);\n            if (auto) {\n                set(result);\n            }\n            else {\n                cleanup = is_function(result) ? result : noop;\n            }\n        };\n        const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {\n            values[i] = value;\n            pending &= ~(1 << i);\n            if (started) {\n                sync();\n            }\n        }, () => {\n            pending |= (1 << i);\n        }));\n        started = true;\n        sync();\n        return function stop() {\n            run_all(unsubscribers);\n            cleanup();\n            // We need to set this to false because callbacks can still happen despite having unsubscribed:\n            // Callbacks might already be placed in the queue which doesn't know it should no longer\n            // invoke this derived store.\n            started = false;\n        };\n    });\n}\n/**\n * Takes a store and returns a new one derived from the old one that is readable.\n *\n * @param store - store to make readonly\n */\nfunction readonly(store) {\n    return {\n        subscribe: store.subscribe.bind(store)\n    };\n}\n\nexport { derived, readable, readonly, writable };\n","/**\n * @license\n * Copyright (c) 2023, Jeff Hlywa (jhlywa@gmail.com)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\nexport const WHITE = 'w';\nexport const BLACK = 'b';\nexport const PAWN = 'p';\nexport const KNIGHT = 'n';\nexport const BISHOP = 'b';\nexport const ROOK = 'r';\nexport const QUEEN = 'q';\nexport const KING = 'k';\nexport const DEFAULT_POSITION = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';\nconst EMPTY = -1;\nconst FLAGS = {\n    NORMAL: 'n',\n    CAPTURE: 'c',\n    BIG_PAWN: 'b',\n    EP_CAPTURE: 'e',\n    PROMOTION: 'p',\n    KSIDE_CASTLE: 'k',\n    QSIDE_CASTLE: 'q',\n};\n// prettier-ignore\nexport const SQUARES = [\n    'a8', 'b8', 'c8', 'd8', 'e8', 'f8', 'g8', 'h8',\n    'a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7',\n    'a6', 'b6', 'c6', 'd6', 'e6', 'f6', 'g6', 'h6',\n    'a5', 'b5', 'c5', 'd5', 'e5', 'f5', 'g5', 'h5',\n    'a4', 'b4', 'c4', 'd4', 'e4', 'f4', 'g4', 'h4',\n    'a3', 'b3', 'c3', 'd3', 'e3', 'f3', 'g3', 'h3',\n    'a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2',\n    'a1', 'b1', 'c1', 'd1', 'e1', 'f1', 'g1', 'h1'\n];\nconst BITS = {\n    NORMAL: 1,\n    CAPTURE: 2,\n    BIG_PAWN: 4,\n    EP_CAPTURE: 8,\n    PROMOTION: 16,\n    KSIDE_CASTLE: 32,\n    QSIDE_CASTLE: 64,\n};\n/*\n * NOTES ABOUT 0x88 MOVE GENERATION ALGORITHM\n * ----------------------------------------------------------------------------\n * From https://github.com/jhlywa/chess.js/issues/230\n *\n * A lot of people are confused when they first see the internal representation\n * of chess.js. It uses the 0x88 Move Generation Algorithm which internally\n * stores the board as an 8x16 array. This is purely for efficiency but has a\n * couple of interesting benefits:\n *\n * 1. 0x88 offers a very inexpensive \"off the board\" check. Bitwise AND (&) any\n *    square with 0x88, if the result is non-zero then the square is off the\n *    board. For example, assuming a knight square A8 (0 in 0x88 notation),\n *    there are 8 possible directions in which the knight can move. These\n *    directions are relative to the 8x16 board and are stored in the\n *    PIECE_OFFSETS map. One possible move is A8 - 18 (up one square, and two\n *    squares to the left - which is off the board). 0 - 18 = -18 & 0x88 = 0x88\n *    (because of two-complement representation of -18). The non-zero result\n *    means the square is off the board and the move is illegal. Take the\n *    opposite move (from A8 to C7), 0 + 18 = 18 & 0x88 = 0. A result of zero\n *    means the square is on the board.\n *\n * 2. The relative distance (or difference) between two squares on a 8x16 board\n *    is unique and can be used to inexpensively determine if a piece on a\n *    square can attack any other arbitrary square. For example, let's see if a\n *    pawn on E7 can attack E2. The difference between E7 (20) - E2 (100) is\n *    -80. We add 119 to make the ATTACKS array index non-negative (because the\n *    worst case difference is A8 - H1 = -119). The ATTACKS array contains a\n *    bitmask of pieces that can attack from that distance and direction.\n *    ATTACKS[-80 + 119=39] gives us 24 or 0b11000 in binary. Look at the\n *    PIECE_MASKS map to determine the mask for a given piece type. In our pawn\n *    example, we would check to see if 24 & 0x1 is non-zero, which it is\n *    not. So, naturally, a pawn on E7 can't attack a piece on E2. However, a\n *    rook can since 24 & 0x8 is non-zero. The only thing left to check is that\n *    there are no blocking pieces between E7 and E2. That's where the RAYS\n *    array comes in. It provides an offset (in this case 16) to add to E7 (20)\n *    to check for blocking pieces. E7 (20) + 16 = E6 (36) + 16 = E5 (52) etc.\n */\n// prettier-ignore\n// eslint-disable-next-line\nconst Ox88 = {\n    a8: 0, b8: 1, c8: 2, d8: 3, e8: 4, f8: 5, g8: 6, h8: 7,\n    a7: 16, b7: 17, c7: 18, d7: 19, e7: 20, f7: 21, g7: 22, h7: 23,\n    a6: 32, b6: 33, c6: 34, d6: 35, e6: 36, f6: 37, g6: 38, h6: 39,\n    a5: 48, b5: 49, c5: 50, d5: 51, e5: 52, f5: 53, g5: 54, h5: 55,\n    a4: 64, b4: 65, c4: 66, d4: 67, e4: 68, f4: 69, g4: 70, h4: 71,\n    a3: 80, b3: 81, c3: 82, d3: 83, e3: 84, f3: 85, g3: 86, h3: 87,\n    a2: 96, b2: 97, c2: 98, d2: 99, e2: 100, f2: 101, g2: 102, h2: 103,\n    a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119\n};\nconst PAWN_OFFSETS = {\n    b: [16, 32, 17, 15],\n    w: [-16, -32, -17, -15],\n};\nconst PIECE_OFFSETS = {\n    n: [-18, -33, -31, -14, 18, 33, 31, 14],\n    b: [-17, -15, 17, 15],\n    r: [-16, 1, 16, -1],\n    q: [-17, -16, -15, 1, 17, 16, 15, -1],\n    k: [-17, -16, -15, 1, 17, 16, 15, -1],\n};\n// prettier-ignore\nconst ATTACKS = [\n    20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20, 0,\n    0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,\n    0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,\n    0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,\n    0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n    24, 24, 24, 24, 24, 24, 56, 0, 56, 24, 24, 24, 24, 24, 24, 0,\n    0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,\n    0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,\n    0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,\n    0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,\n    20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20\n];\n// prettier-ignore\nconst RAYS = [\n    17, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 15, 0,\n    0, 17, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 15, 0, 0,\n    0, 0, 17, 0, 0, 0, 0, 16, 0, 0, 0, 0, 15, 0, 0, 0,\n    0, 0, 0, 17, 0, 0, 0, 16, 0, 0, 0, 15, 0, 0, 0, 0,\n    0, 0, 0, 0, 17, 0, 0, 16, 0, 0, 15, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 17, 0, 16, 0, 15, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 17, 16, 15, 0, 0, 0, 0, 0, 0, 0,\n    1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 0,\n    0, 0, 0, 0, 0, 0, -15, -16, -17, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, -15, 0, -16, 0, -17, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -15, 0, 0, -16, 0, 0, -17, 0, 0, 0, 0, 0,\n    0, 0, 0, -15, 0, 0, 0, -16, 0, 0, 0, -17, 0, 0, 0, 0,\n    0, 0, -15, 0, 0, 0, 0, -16, 0, 0, 0, 0, -17, 0, 0, 0,\n    0, -15, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, -17, 0, 0,\n    -15, 0, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, 0, -17\n];\nconst PIECE_MASKS = { p: 0x1, n: 0x2, b: 0x4, r: 0x8, q: 0x10, k: 0x20 };\nconst SYMBOLS = 'pnbrqkPNBRQK';\nconst PROMOTIONS = [KNIGHT, BISHOP, ROOK, QUEEN];\nconst RANK_1 = 7;\nconst RANK_2 = 6;\n/*\n * const RANK_3 = 5\n * const RANK_4 = 4\n * const RANK_5 = 3\n * const RANK_6 = 2\n */\nconst RANK_7 = 1;\nconst RANK_8 = 0;\nconst ROOKS = {\n    w: [\n        { square: Ox88.a1, flag: BITS.QSIDE_CASTLE },\n        { square: Ox88.h1, flag: BITS.KSIDE_CASTLE },\n    ],\n    b: [\n        { square: Ox88.a8, flag: BITS.QSIDE_CASTLE },\n        { square: Ox88.h8, flag: BITS.KSIDE_CASTLE },\n    ],\n};\nconst SECOND_RANK = { b: RANK_7, w: RANK_2 };\nconst TERMINATION_MARKERS = ['1-0', '0-1', '1/2-1/2', '*'];\n// Extracts the zero-based rank of an 0x88 square.\nfunction rank(square) {\n    return square >> 4;\n}\n// Extracts the zero-based file of an 0x88 square.\nfunction file(square) {\n    return square & 0xf;\n}\nfunction isDigit(c) {\n    return '0123456789'.indexOf(c) !== -1;\n}\n// Converts a 0x88 square to algebraic notation.\nfunction algebraic(square) {\n    const f = file(square);\n    const r = rank(square);\n    return ('abcdefgh'.substring(f, f + 1) +\n        '87654321'.substring(r, r + 1));\n}\nfunction swapColor(color) {\n    return color === WHITE ? BLACK : WHITE;\n}\nexport function validateFen(fen) {\n    // 1st criterion: 6 space-seperated fields?\n    const tokens = fen.split(/\\s+/);\n    if (tokens.length !== 6) {\n        return {\n            ok: false,\n            error: 'Invalid FEN: must contain six space-delimited fields',\n        };\n    }\n    // 2nd criterion: move number field is a integer value > 0?\n    const moveNumber = parseInt(tokens[5], 10);\n    if (isNaN(moveNumber) || moveNumber <= 0) {\n        return {\n            ok: false,\n            error: 'Invalid FEN: move number must be a positive integer',\n        };\n    }\n    // 3rd criterion: half move counter is an integer >= 0?\n    const halfMoves = parseInt(tokens[4], 10);\n    if (isNaN(halfMoves) || halfMoves < 0) {\n        return {\n            ok: false,\n            error: 'Invalid FEN: half move counter number must be a non-negative integer',\n        };\n    }\n    // 4th criterion: 4th field is a valid e.p.-string?\n    if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n        return { ok: false, error: 'Invalid FEN: en-passant square is invalid' };\n    }\n    // 5th criterion: 3th field is a valid castle-string?\n    if (/[^kKqQ-]/.test(tokens[2])) {\n        return { ok: false, error: 'Invalid FEN: castling availability is invalid' };\n    }\n    // 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)?\n    if (!/^(w|b)$/.test(tokens[1])) {\n        return { ok: false, error: 'Invalid FEN: side-to-move is invalid' };\n    }\n    // 7th criterion: 1st field contains 8 rows?\n    const rows = tokens[0].split('/');\n    if (rows.length !== 8) {\n        return {\n            ok: false,\n            error: \"Invalid FEN: piece data does not contain 8 '/'-delimited rows\",\n        };\n    }\n    // 8th criterion: every row is valid?\n    for (let i = 0; i < rows.length; i++) {\n        // check for right sum of fields AND not two numbers in succession\n        let sumFields = 0;\n        let previousWasNumber = false;\n        for (let k = 0; k < rows[i].length; k++) {\n            if (isDigit(rows[i][k])) {\n                if (previousWasNumber) {\n                    return {\n                        ok: false,\n                        error: 'Invalid FEN: piece data is invalid (consecutive number)',\n                    };\n                }\n                sumFields += parseInt(rows[i][k], 10);\n                previousWasNumber = true;\n            }\n            else {\n                if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n                    return {\n                        ok: false,\n                        error: 'Invalid FEN: piece data is invalid (invalid piece)',\n                    };\n                }\n                sumFields += 1;\n                previousWasNumber = false;\n            }\n        }\n        if (sumFields !== 8) {\n            return {\n                ok: false,\n                error: 'Invalid FEN: piece data is invalid (too many squares in rank)',\n            };\n        }\n    }\n    if ((tokens[3][1] == '3' && tokens[1] == 'w') ||\n        (tokens[3][1] == '6' && tokens[1] == 'b')) {\n        return { ok: false, error: 'Invalid FEN: illegal en-passant square' };\n    }\n    const kings = [\n        { color: 'white', regex: /K/g },\n        { color: 'black', regex: /k/g },\n    ];\n    for (const { color, regex } of kings) {\n        if (!regex.test(tokens[0])) {\n            return { ok: false, error: `Invalid FEN: missing ${color} king` };\n        }\n        if ((tokens[0].match(regex) || []).length > 1) {\n            return { ok: false, error: `Invalid FEN: too many ${color} kings` };\n        }\n    }\n    return { ok: true };\n}\n// this function is used to uniquely identify ambiguous moves\nfunction getDisambiguator(move, moves) {\n    const from = move.from;\n    const to = move.to;\n    const piece = move.piece;\n    let ambiguities = 0;\n    let sameRank = 0;\n    let sameFile = 0;\n    for (let i = 0, len = moves.length; i < len; i++) {\n        const ambigFrom = moves[i].from;\n        const ambigTo = moves[i].to;\n        const ambigPiece = moves[i].piece;\n        /*\n         * if a move of the same piece type ends on the same to square, we'll need\n         * to add a disambiguator to the algebraic notation\n         */\n        if (piece === ambigPiece && from !== ambigFrom && to === ambigTo) {\n            ambiguities++;\n            if (rank(from) === rank(ambigFrom)) {\n                sameRank++;\n            }\n            if (file(from) === file(ambigFrom)) {\n                sameFile++;\n            }\n        }\n    }\n    if (ambiguities > 0) {\n        if (sameRank > 0 && sameFile > 0) {\n            /*\n             * if there exists a similar moving piece on the same rank and file as\n             * the move in question, use the square as the disambiguator\n             */\n            return algebraic(from);\n        }\n        else if (sameFile > 0) {\n            /*\n             * if the moving piece rests on the same file, use the rank symbol as the\n             * disambiguator\n             */\n            return algebraic(from).charAt(1);\n        }\n        else {\n            // else use the file symbol\n            return algebraic(from).charAt(0);\n        }\n    }\n    return '';\n}\nfunction addMove(moves, color, from, to, piece, captured = undefined, flags = BITS.NORMAL) {\n    const r = rank(to);\n    if (piece === PAWN && (r === RANK_1 || r === RANK_8)) {\n        for (let i = 0; i < PROMOTIONS.length; i++) {\n            const promotion = PROMOTIONS[i];\n            moves.push({\n                color,\n                from,\n                to,\n                piece,\n                captured,\n                promotion,\n                flags: flags | BITS.PROMOTION,\n            });\n        }\n    }\n    else {\n        moves.push({\n            color,\n            from,\n            to,\n            piece,\n            captured,\n            flags,\n        });\n    }\n}\nfunction inferPieceType(san) {\n    let pieceType = san.charAt(0);\n    if (pieceType >= 'a' && pieceType <= 'h') {\n        const matches = san.match(/[a-h]\\d.*[a-h]\\d/);\n        if (matches) {\n            return undefined;\n        }\n        return PAWN;\n    }\n    pieceType = pieceType.toLowerCase();\n    if (pieceType === 'o') {\n        return KING;\n    }\n    return pieceType;\n}\n// parses all of the decorators out of a SAN string\nfunction strippedSan(move) {\n    return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '');\n}\nexport class Chess {\n    constructor(fen = DEFAULT_POSITION) {\n        this._board = new Array(128);\n        this._turn = WHITE;\n        this._header = {};\n        this._kings = { w: EMPTY, b: EMPTY };\n        this._epSquare = -1;\n        this._halfMoves = 0;\n        this._moveNumber = 0;\n        this._history = [];\n        this._comments = {};\n        this._castling = { w: 0, b: 0 };\n        this.load(fen);\n    }\n    clear(keepHeaders = false) {\n        this._board = new Array(128);\n        this._kings = { w: EMPTY, b: EMPTY };\n        this._turn = WHITE;\n        this._castling = { w: 0, b: 0 };\n        this._epSquare = EMPTY;\n        this._halfMoves = 0;\n        this._moveNumber = 1;\n        this._history = [];\n        this._comments = {};\n        this._header = keepHeaders ? this._header : {};\n        this._updateSetup(this.fen());\n    }\n    load(fen, keepHeaders = false) {\n        let tokens = fen.split(/\\s+/);\n        // append commonly omitted fen tokens\n        if (tokens.length >= 2 && tokens.length < 6) {\n            const adjustments = ['-', '-', '0', '1'];\n            fen = tokens.concat(adjustments.slice(-(6 - tokens.length))).join(' ');\n        }\n        tokens = fen.split(/\\s+/);\n        const { ok, error } = validateFen(fen);\n        if (!ok) {\n            throw new Error(error);\n        }\n        const position = tokens[0];\n        let square = 0;\n        this.clear(keepHeaders);\n        for (let i = 0; i < position.length; i++) {\n            const piece = position.charAt(i);\n            if (piece === '/') {\n                square += 8;\n            }\n            else if (isDigit(piece)) {\n                square += parseInt(piece, 10);\n            }\n            else {\n                const color = piece < 'a' ? WHITE : BLACK;\n                this.put({ type: piece.toLowerCase(), color }, algebraic(square));\n                square++;\n            }\n        }\n        this._turn = tokens[1];\n        if (tokens[2].indexOf('K') > -1) {\n            this._castling.w |= BITS.KSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('Q') > -1) {\n            this._castling.w |= BITS.QSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('k') > -1) {\n            this._castling.b |= BITS.KSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('q') > -1) {\n            this._castling.b |= BITS.QSIDE_CASTLE;\n        }\n        this._epSquare = tokens[3] === '-' ? EMPTY : Ox88[tokens[3]];\n        this._halfMoves = parseInt(tokens[4], 10);\n        this._moveNumber = parseInt(tokens[5], 10);\n        this._updateSetup(this.fen());\n    }\n    fen() {\n        var _a, _b;\n        let empty = 0;\n        let fen = '';\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            if (this._board[i]) {\n                if (empty > 0) {\n                    fen += empty;\n                    empty = 0;\n                }\n                const { color, type: piece } = this._board[i];\n                fen += color === WHITE ? piece.toUpperCase() : piece.toLowerCase();\n            }\n            else {\n                empty++;\n            }\n            if ((i + 1) & 0x88) {\n                if (empty > 0) {\n                    fen += empty;\n                }\n                if (i !== Ox88.h1) {\n                    fen += '/';\n                }\n                empty = 0;\n                i += 8;\n            }\n        }\n        let castling = '';\n        if (this._castling[WHITE] & BITS.KSIDE_CASTLE) {\n            castling += 'K';\n        }\n        if (this._castling[WHITE] & BITS.QSIDE_CASTLE) {\n            castling += 'Q';\n        }\n        if (this._castling[BLACK] & BITS.KSIDE_CASTLE) {\n            castling += 'k';\n        }\n        if (this._castling[BLACK] & BITS.QSIDE_CASTLE) {\n            castling += 'q';\n        }\n        // do we have an empty castling flag?\n        castling = castling || '-';\n        let epSquare = '-';\n        /*\n         * only print the ep square if en passant is a valid move (pawn is present\n         * and ep capture is not pinned)\n         */\n        if (this._epSquare !== EMPTY) {\n            const bigPawnSquare = this._epSquare + (this._turn === WHITE ? 16 : -16);\n            const squares = [bigPawnSquare + 1, bigPawnSquare - 1];\n            for (const square of squares) {\n                // is the square off the board?\n                if (square & 0x88) {\n                    continue;\n                }\n                const color = this._turn;\n                // is there a pawn that can capture the epSquare?\n                if (((_a = this._board[square]) === null || _a === void 0 ? void 0 : _a.color) === color &&\n                    ((_b = this._board[square]) === null || _b === void 0 ? void 0 : _b.type) === PAWN) {\n                    // if the pawn makes an ep capture, does it leave it's king in check?\n                    this._makeMove({\n                        color,\n                        from: square,\n                        to: this._epSquare,\n                        piece: PAWN,\n                        captured: PAWN,\n                        flags: BITS.EP_CAPTURE,\n                    });\n                    const isLegal = !this._isKingAttacked(color);\n                    this._undoMove();\n                    // if ep is legal, break and set the ep square in the FEN output\n                    if (isLegal) {\n                        epSquare = algebraic(this._epSquare);\n                        break;\n                    }\n                }\n            }\n        }\n        return [\n            fen,\n            this._turn,\n            castling,\n            epSquare,\n            this._halfMoves,\n            this._moveNumber,\n        ].join(' ');\n    }\n    /*\n     * Called when the initial board setup is changed with put() or remove().\n     * modifies the SetUp and FEN properties of the header object. If the FEN\n     * is equal to the default position, the SetUp and FEN are deleted the setup\n     * is only updated if history.length is zero, ie moves haven't been made.\n     */\n    _updateSetup(fen) {\n        if (this._history.length > 0)\n            return;\n        if (fen !== DEFAULT_POSITION) {\n            this._header['SetUp'] = '1';\n            this._header['FEN'] = fen;\n        }\n        else {\n            delete this._header['SetUp'];\n            delete this._header['FEN'];\n        }\n    }\n    reset() {\n        this.load(DEFAULT_POSITION);\n    }\n    get(square) {\n        return this._board[Ox88[square]] || false;\n    }\n    put({ type, color }, square) {\n        // check for piece\n        if (SYMBOLS.indexOf(type.toLowerCase()) === -1) {\n            return false;\n        }\n        // check for valid square\n        if (!(square in Ox88)) {\n            return false;\n        }\n        const sq = Ox88[square];\n        // don't let the user place more than one king\n        if (type == KING &&\n            !(this._kings[color] == EMPTY || this._kings[color] == sq)) {\n            return false;\n        }\n        this._board[sq] = { type: type, color: color };\n        if (type === KING) {\n            this._kings[color] = sq;\n        }\n        this._updateSetup(this.fen());\n        return true;\n    }\n    remove(square) {\n        const piece = this.get(square);\n        delete this._board[Ox88[square]];\n        if (piece && piece.type === KING) {\n            this._kings[piece.color] = EMPTY;\n        }\n        this._updateSetup(this.fen());\n        return piece;\n    }\n    _attacked(color, square) {\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            // did we run off the end of the board\n            if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            // if empty square or wrong color\n            if (this._board[i] === undefined || this._board[i].color !== color) {\n                continue;\n            }\n            const piece = this._board[i];\n            const difference = i - square;\n            // skip - to/from square are the same\n            if (difference === 0) {\n                continue;\n            }\n            const index = difference + 119;\n            if (ATTACKS[index] & PIECE_MASKS[piece.type]) {\n                if (piece.type === PAWN) {\n                    if (difference > 0) {\n                        if (piece.color === WHITE)\n                            return true;\n                    }\n                    else {\n                        if (piece.color === BLACK)\n                            return true;\n                    }\n                    continue;\n                }\n                // if the piece is a knight or a king\n                if (piece.type === 'n' || piece.type === 'k')\n                    return true;\n                const offset = RAYS[index];\n                let j = i + offset;\n                let blocked = false;\n                while (j !== square) {\n                    if (this._board[j] != null) {\n                        blocked = true;\n                        break;\n                    }\n                    j += offset;\n                }\n                if (!blocked)\n                    return true;\n            }\n        }\n        return false;\n    }\n    _isKingAttacked(color) {\n        return this._attacked(swapColor(color), this._kings[color]);\n    }\n    isAttacked(square, attackedBy) {\n        return this._attacked(attackedBy, Ox88[square]);\n    }\n    isCheck() {\n        return this._isKingAttacked(this._turn);\n    }\n    inCheck() {\n        return this.isCheck();\n    }\n    isCheckmate() {\n        return this.isCheck() && this._moves().length === 0;\n    }\n    isStalemate() {\n        return !this.isCheck() && this._moves().length === 0;\n    }\n    isInsufficientMaterial() {\n        /*\n         * k.b. vs k.b. (of opposite colors) with mate in 1:\n         * 8/8/8/8/1b6/8/B1k5/K7 b - - 0 1\n         *\n         * k.b. vs k.n. with mate in 1:\n         * 8/8/8/8/1n6/8/B7/K1k5 b - - 2 1\n         */\n        const pieces = {\n            b: 0,\n            n: 0,\n            r: 0,\n            q: 0,\n            k: 0,\n            p: 0,\n        };\n        const bishops = [];\n        let numPieces = 0;\n        let squareColor = 0;\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            squareColor = (squareColor + 1) % 2;\n            if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            const piece = this._board[i];\n            if (piece) {\n                pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1;\n                if (piece.type === BISHOP) {\n                    bishops.push(squareColor);\n                }\n                numPieces++;\n            }\n        }\n        // k vs. k\n        if (numPieces === 2) {\n            return true;\n        }\n        else if (\n        // k vs. kn .... or .... k vs. kb\n        numPieces === 3 &&\n            (pieces[BISHOP] === 1 || pieces[KNIGHT] === 1)) {\n            return true;\n        }\n        else if (numPieces === pieces[BISHOP] + 2) {\n            // kb vs. kb where any number of bishops are all on the same color\n            let sum = 0;\n            const len = bishops.length;\n            for (let i = 0; i < len; i++) {\n                sum += bishops[i];\n            }\n            if (sum === 0 || sum === len) {\n                return true;\n            }\n        }\n        return false;\n    }\n    isThreefoldRepetition() {\n        const moves = [];\n        const positions = {};\n        let repetition = false;\n        while (true) {\n            const move = this._undoMove();\n            if (!move)\n                break;\n            moves.push(move);\n        }\n        while (true) {\n            /*\n             * remove the last two fields in the FEN string, they're not needed when\n             * checking for draw by rep\n             */\n            const fen = this.fen().split(' ').slice(0, 4).join(' ');\n            // has the position occurred three or move times\n            positions[fen] = fen in positions ? positions[fen] + 1 : 1;\n            if (positions[fen] >= 3) {\n                repetition = true;\n            }\n            const move = moves.pop();\n            if (!move) {\n                break;\n            }\n            else {\n                this._makeMove(move);\n            }\n        }\n        return repetition;\n    }\n    isDraw() {\n        return (this._halfMoves >= 100 || // 50 moves per side = 100 half moves\n            this.isStalemate() ||\n            this.isInsufficientMaterial() ||\n            this.isThreefoldRepetition());\n    }\n    isGameOver() {\n        return this.isCheckmate() || this.isStalemate() || this.isDraw();\n    }\n    moves({ verbose = false, square = undefined, piece = undefined, } = {}) {\n        const moves = this._moves({ square, piece });\n        if (verbose) {\n            return moves.map((move) => this._makePretty(move));\n        }\n        else {\n            return moves.map((move) => this._moveToSan(move, moves));\n        }\n    }\n    _moves({ legal = true, piece = undefined, square = undefined, } = {}) {\n        var _a;\n        const forSquare = square ? square.toLowerCase() : undefined;\n        const forPiece = piece === null || piece === void 0 ? void 0 : piece.toLowerCase();\n        const moves = [];\n        const us = this._turn;\n        const them = swapColor(us);\n        let firstSquare = Ox88.a8;\n        let lastSquare = Ox88.h1;\n        let singleSquare = false;\n        // are we generating moves for a single square?\n        if (forSquare) {\n            // illegal square, return empty moves\n            if (!(forSquare in Ox88)) {\n                return [];\n            }\n            else {\n                firstSquare = lastSquare = Ox88[forSquare];\n                singleSquare = true;\n            }\n        }\n        for (let from = firstSquare; from <= lastSquare; from++) {\n            // did we run off the end of the board\n            if (from & 0x88) {\n                from += 7;\n                continue;\n            }\n            // empty square or opponent, skip\n            if (!this._board[from] || this._board[from].color === them) {\n                continue;\n            }\n            const { type } = this._board[from];\n            let to;\n            if (type === PAWN) {\n                if (forPiece && forPiece !== type)\n                    continue;\n                // single square, non-capturing\n                to = from + PAWN_OFFSETS[us][0];\n                if (!this._board[to]) {\n                    addMove(moves, us, from, to, PAWN);\n                    // double square\n                    to = from + PAWN_OFFSETS[us][1];\n                    if (SECOND_RANK[us] === rank(from) && !this._board[to]) {\n                        addMove(moves, us, from, to, PAWN, undefined, BITS.BIG_PAWN);\n                    }\n                }\n                // pawn captures\n                for (let j = 2; j < 4; j++) {\n                    to = from + PAWN_OFFSETS[us][j];\n                    if (to & 0x88)\n                        continue;\n                    if (((_a = this._board[to]) === null || _a === void 0 ? void 0 : _a.color) === them) {\n                        addMove(moves, us, from, to, PAWN, this._board[to].type, BITS.CAPTURE);\n                    }\n                    else if (to === this._epSquare) {\n                        addMove(moves, us, from, to, PAWN, PAWN, BITS.EP_CAPTURE);\n                    }\n                }\n            }\n            else {\n                if (forPiece && forPiece !== type)\n                    continue;\n                for (let j = 0, len = PIECE_OFFSETS[type].length; j < len; j++) {\n                    const offset = PIECE_OFFSETS[type][j];\n                    to = from;\n                    while (true) {\n                        to += offset;\n                        if (to & 0x88)\n                            break;\n                        if (!this._board[to]) {\n                            addMove(moves, us, from, to, type);\n                        }\n                        else {\n                            // own color, stop loop\n                            if (this._board[to].color === us)\n                                break;\n                            addMove(moves, us, from, to, type, this._board[to].type, BITS.CAPTURE);\n                            break;\n                        }\n                        /* break, if knight or king */\n                        if (type === KNIGHT || type === KING)\n                            break;\n                    }\n                }\n            }\n        }\n        /*\n         * check for castling if we're:\n         *   a) generating all moves, or\n         *   b) doing single square move generation on the king's square\n         */\n        if (forPiece === undefined || forPiece === KING) {\n            if (!singleSquare || lastSquare === this._kings[us]) {\n                // king-side castling\n                if (this._castling[us] & BITS.KSIDE_CASTLE) {\n                    const castlingFrom = this._kings[us];\n                    const castlingTo = castlingFrom + 2;\n                    if (!this._board[castlingFrom + 1] &&\n                        !this._board[castlingTo] &&\n                        !this._attacked(them, this._kings[us]) &&\n                        !this._attacked(them, castlingFrom + 1) &&\n                        !this._attacked(them, castlingTo)) {\n                        addMove(moves, us, this._kings[us], castlingTo, KING, undefined, BITS.KSIDE_CASTLE);\n                    }\n                }\n                // queen-side castling\n                if (this._castling[us] & BITS.QSIDE_CASTLE) {\n                    const castlingFrom = this._kings[us];\n                    const castlingTo = castlingFrom - 2;\n                    if (!this._board[castlingFrom - 1] &&\n                        !this._board[castlingFrom - 2] &&\n                        !this._board[castlingFrom - 3] &&\n                        !this._attacked(them, this._kings[us]) &&\n                        !this._attacked(them, castlingFrom - 1) &&\n                        !this._attacked(them, castlingTo)) {\n                        addMove(moves, us, this._kings[us], castlingTo, KING, undefined, BITS.QSIDE_CASTLE);\n                    }\n                }\n            }\n        }\n        /*\n         * return all pseudo-legal moves (this includes moves that allow the king\n         * to be captured)\n         */\n        if (!legal) {\n            return moves;\n        }\n        // filter out illegal moves\n        const legalMoves = [];\n        for (let i = 0, len = moves.length; i < len; i++) {\n            this._makeMove(moves[i]);\n            if (!this._isKingAttacked(us)) {\n                legalMoves.push(moves[i]);\n            }\n            this._undoMove();\n        }\n        return legalMoves;\n    }\n    move(move, { strict = false } = {}) {\n        /*\n         * The move function can be called with in the following parameters:\n         *\n         * .move('Nxb7')       <- argument is a case-sensitive SAN string\n         *\n         * .move({ from: 'h7', <- argument is a move object\n         *         to :'h8',\n         *         promotion: 'q' })\n         *\n         *\n         * An optional strict argument may be supplied to tell chess.js to\n         * strictly follow the SAN specification.\n         */\n        let moveObj = null;\n        if (typeof move === 'string') {\n            moveObj = this._moveFromSan(move, strict);\n        }\n        else if (typeof move === 'object') {\n            const moves = this._moves();\n            // convert the pretty move object to an ugly move object\n            for (let i = 0, len = moves.length; i < len; i++) {\n                if (move.from === algebraic(moves[i].from) &&\n                    move.to === algebraic(moves[i].to) &&\n                    (!('promotion' in moves[i]) || move.promotion === moves[i].promotion)) {\n                    moveObj = moves[i];\n                    break;\n                }\n            }\n        }\n        // failed to find move\n        if (!moveObj) {\n            if (typeof move === 'string') {\n                throw new Error(`Invalid move: ${move}`);\n            }\n            else {\n                throw new Error(`Invalid move: ${JSON.stringify(move)}`);\n            }\n        }\n        /*\n         * need to make a copy of move because we can't generate SAN after the move\n         * is made\n         */\n        const prettyMove = this._makePretty(moveObj);\n        this._makeMove(moveObj);\n        return prettyMove;\n    }\n    _push(move) {\n        this._history.push({\n            move,\n            kings: { b: this._kings.b, w: this._kings.w },\n            turn: this._turn,\n            castling: { b: this._castling.b, w: this._castling.w },\n            epSquare: this._epSquare,\n            halfMoves: this._halfMoves,\n            moveNumber: this._moveNumber,\n        });\n    }\n    _makeMove(move) {\n        const us = this._turn;\n        const them = swapColor(us);\n        this._push(move);\n        this._board[move.to] = this._board[move.from];\n        delete this._board[move.from];\n        // if ep capture, remove the captured pawn\n        if (move.flags & BITS.EP_CAPTURE) {\n            if (this._turn === BLACK) {\n                delete this._board[move.to - 16];\n            }\n            else {\n                delete this._board[move.to + 16];\n            }\n        }\n        // if pawn promotion, replace with new piece\n        if (move.promotion) {\n            this._board[move.to] = { type: move.promotion, color: us };\n        }\n        // if we moved the king\n        if (this._board[move.to].type === KING) {\n            this._kings[us] = move.to;\n            // if we castled, move the rook next to the king\n            if (move.flags & BITS.KSIDE_CASTLE) {\n                const castlingTo = move.to - 1;\n                const castlingFrom = move.to + 1;\n                this._board[castlingTo] = this._board[castlingFrom];\n                delete this._board[castlingFrom];\n            }\n            else if (move.flags & BITS.QSIDE_CASTLE) {\n                const castlingTo = move.to + 1;\n                const castlingFrom = move.to - 2;\n                this._board[castlingTo] = this._board[castlingFrom];\n                delete this._board[castlingFrom];\n            }\n            // turn off castling\n            this._castling[us] = 0;\n        }\n        // turn off castling if we move a rook\n        if (this._castling[us]) {\n            for (let i = 0, len = ROOKS[us].length; i < len; i++) {\n                if (move.from === ROOKS[us][i].square &&\n                    this._castling[us] & ROOKS[us][i].flag) {\n                    this._castling[us] ^= ROOKS[us][i].flag;\n                    break;\n                }\n            }\n        }\n        // turn off castling if we capture a rook\n        if (this._castling[them]) {\n            for (let i = 0, len = ROOKS[them].length; i < len; i++) {\n                if (move.to === ROOKS[them][i].square &&\n                    this._castling[them] & ROOKS[them][i].flag) {\n                    this._castling[them] ^= ROOKS[them][i].flag;\n                    break;\n                }\n            }\n        }\n        // if big pawn move, update the en passant square\n        if (move.flags & BITS.BIG_PAWN) {\n            if (us === BLACK) {\n                this._epSquare = move.to - 16;\n            }\n            else {\n                this._epSquare = move.to + 16;\n            }\n        }\n        else {\n            this._epSquare = EMPTY;\n        }\n        // reset the 50 move counter if a pawn is moved or a piece is captured\n        if (move.piece === PAWN) {\n            this._halfMoves = 0;\n        }\n        else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n            this._halfMoves = 0;\n        }\n        else {\n            this._halfMoves++;\n        }\n        if (us === BLACK) {\n            this._moveNumber++;\n        }\n        this._turn = them;\n    }\n    undo() {\n        const move = this._undoMove();\n        return move ? this._makePretty(move) : null;\n    }\n    _undoMove() {\n        const old = this._history.pop();\n        if (old === undefined) {\n            return null;\n        }\n        const move = old.move;\n        this._kings = old.kings;\n        this._turn = old.turn;\n        this._castling = old.castling;\n        this._epSquare = old.epSquare;\n        this._halfMoves = old.halfMoves;\n        this._moveNumber = old.moveNumber;\n        const us = this._turn;\n        const them = swapColor(us);\n        this._board[move.from] = this._board[move.to];\n        this._board[move.from].type = move.piece; // to undo any promotions\n        delete this._board[move.to];\n        if (move.captured) {\n            if (move.flags & BITS.EP_CAPTURE) {\n                // en passant capture\n                let index;\n                if (us === BLACK) {\n                    index = move.to - 16;\n                }\n                else {\n                    index = move.to + 16;\n                }\n                this._board[index] = { type: PAWN, color: them };\n            }\n            else {\n                // regular capture\n                this._board[move.to] = { type: move.captured, color: them };\n            }\n        }\n        if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\n            let castlingTo, castlingFrom;\n            if (move.flags & BITS.KSIDE_CASTLE) {\n                castlingTo = move.to + 1;\n                castlingFrom = move.to - 1;\n            }\n            else {\n                castlingTo = move.to - 2;\n                castlingFrom = move.to + 1;\n            }\n            this._board[castlingTo] = this._board[castlingFrom];\n            delete this._board[castlingFrom];\n        }\n        return move;\n    }\n    pgn({ newline = '\\n', maxWidth = 0, } = {}) {\n        /*\n         * using the specification from http://www.chessclub.com/help/PGN-spec\n         * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\n         */\n        const result = [];\n        let headerExists = false;\n        /* add the PGN header information */\n        for (const i in this._header) {\n            /*\n             * TODO: order of enumerated properties in header object is not\n             * guaranteed, see ECMA-262 spec (section 12.6.4)\n             */\n            result.push('[' + i + ' \"' + this._header[i] + '\"]' + newline);\n            headerExists = true;\n        }\n        if (headerExists && this._history.length) {\n            result.push(newline);\n        }\n        const appendComment = (moveString) => {\n            const comment = this._comments[this.fen()];\n            if (typeof comment !== 'undefined') {\n                const delimiter = moveString.length > 0 ? ' ' : '';\n                moveString = `${moveString}${delimiter}{${comment}}`;\n            }\n            return moveString;\n        };\n        // pop all of history onto reversed_history\n        const reversedHistory = [];\n        while (this._history.length > 0) {\n            reversedHistory.push(this._undoMove());\n        }\n        const moves = [];\n        let moveString = '';\n        // special case of a commented starting position with no moves\n        if (reversedHistory.length === 0) {\n            moves.push(appendComment(''));\n        }\n        // build the list of moves.  a move_string looks like: \"3. e3 e6\"\n        while (reversedHistory.length > 0) {\n            moveString = appendComment(moveString);\n            const move = reversedHistory.pop();\n            // make TypeScript stop complaining about move being undefined\n            if (!move) {\n                break;\n            }\n            // if the position started with black to move, start PGN with #. ...\n            if (!this._history.length && move.color === 'b') {\n                const prefix = `${this._moveNumber}. ...`;\n                // is there a comment preceding the first move?\n                moveString = moveString ? `${moveString} ${prefix}` : prefix;\n            }\n            else if (move.color === 'w') {\n                // store the previous generated move_string if we have one\n                if (moveString.length) {\n                    moves.push(moveString);\n                }\n                moveString = this._moveNumber + '.';\n            }\n            moveString =\n                moveString + ' ' + this._moveToSan(move, this._moves({ legal: true }));\n            this._makeMove(move);\n        }\n        // are there any other leftover moves?\n        if (moveString.length) {\n            moves.push(appendComment(moveString));\n        }\n        // is there a result?\n        if (typeof this._header.Result !== 'undefined') {\n            moves.push(this._header.Result);\n        }\n        /*\n         * history should be back to what it was before we started generating PGN,\n         * so join together moves\n         */\n        if (maxWidth === 0) {\n            return result.join('') + moves.join(' ');\n        }\n        // TODO (jah): huh?\n        const strip = function () {\n            if (result.length > 0 && result[result.length - 1] === ' ') {\n                result.pop();\n                return true;\n            }\n            return false;\n        };\n        // NB: this does not preserve comment whitespace.\n        const wrapComment = function (width, move) {\n            for (const token of move.split(' ')) {\n                if (!token) {\n                    continue;\n                }\n                if (width + token.length > maxWidth) {\n                    while (strip()) {\n                        width--;\n                    }\n                    result.push(newline);\n                    width = 0;\n                }\n                result.push(token);\n                width += token.length;\n                result.push(' ');\n                width++;\n            }\n            if (strip()) {\n                width--;\n            }\n            return width;\n        };\n        // wrap the PGN output at max_width\n        let currentWidth = 0;\n        for (let i = 0; i < moves.length; i++) {\n            if (currentWidth + moves[i].length > maxWidth) {\n                if (moves[i].includes('{')) {\n                    currentWidth = wrapComment(currentWidth, moves[i]);\n                    continue;\n                }\n            }\n            // if the current move will push past max_width\n            if (currentWidth + moves[i].length > maxWidth && i !== 0) {\n                // don't end the line with whitespace\n                if (result[result.length - 1] === ' ') {\n                    result.pop();\n                }\n                result.push(newline);\n                currentWidth = 0;\n            }\n            else if (i !== 0) {\n                result.push(' ');\n                currentWidth++;\n            }\n            result.push(moves[i]);\n            currentWidth += moves[i].length;\n        }\n        return result.join('');\n    }\n    header(...args) {\n        for (let i = 0; i < args.length; i += 2) {\n            if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {\n                this._header[args[i]] = args[i + 1];\n            }\n        }\n        return this._header;\n    }\n    loadPgn(pgn, { strict = false, newlineChar = '\\r?\\n', } = {}) {\n        function mask(str) {\n            return str.replace(/\\\\/g, '\\\\');\n        }\n        function parsePgnHeader(header) {\n            const headerObj = {};\n            const headers = header.split(new RegExp(mask(newlineChar)));\n            let key = '';\n            let value = '';\n            for (let i = 0; i < headers.length; i++) {\n                const regex = /^\\s*\\[\\s*([A-Za-z]+)\\s*\"(.*)\"\\s*\\]\\s*$/;\n                key = headers[i].replace(regex, '$1');\n                value = headers[i].replace(regex, '$2');\n                if (key.trim().length > 0) {\n                    headerObj[key] = value;\n                }\n            }\n            return headerObj;\n        }\n        // strip whitespace from head/tail of PGN block\n        pgn = pgn.trim();\n        /*\n         * RegExp to split header. Takes advantage of the fact that header and movetext\n         * will always have a blank line between them (ie, two newline_char's). Handles\n         * case where movetext is empty by matching newlineChar until end of string is\n         * matched - effectively trimming from the end extra newlineChar.\n         *\n         * With default newline_char, will equal:\n         * /^(\\[((?:\\r?\\n)|.)*\\])((?:\\s*\\r?\\n){2}|(?:\\s*\\r?\\n)*$)/\n         */\n        const headerRegex = new RegExp('^(\\\\[((?:' +\n            mask(newlineChar) +\n            ')|.)*\\\\])' +\n            '((?:\\\\s*' +\n            mask(newlineChar) +\n            '){2}|(?:\\\\s*' +\n            mask(newlineChar) +\n            ')*$)');\n        // If no header given, begin with moves.\n        const headerRegexResults = headerRegex.exec(pgn);\n        const headerString = headerRegexResults\n            ? headerRegexResults.length >= 2\n                ? headerRegexResults[1]\n                : ''\n            : '';\n        // Put the board in the starting position\n        this.reset();\n        // parse PGN header\n        const headers = parsePgnHeader(headerString);\n        let fen = '';\n        for (const key in headers) {\n            // check to see user is including fen (possibly with wrong tag case)\n            if (key.toLowerCase() === 'fen') {\n                fen = headers[key];\n            }\n            this.header(key, headers[key]);\n        }\n        /*\n         * the permissive parser should attempt to load a fen tag, even if it's the\n         * wrong case and doesn't include a corresponding [SetUp \"1\"] tag\n         */\n        if (!strict) {\n            if (fen) {\n                this.load(fen, true);\n            }\n        }\n        else {\n            /*\n             * strict parser - load the starting position indicated by [Setup '1']\n             * and [FEN position]\n             */\n            if (headers['SetUp'] === '1') {\n                if (!('FEN' in headers)) {\n                    throw new Error('Invalid PGN: FEN tag must be supplied with SetUp tag');\n                }\n                // second argument to load: don't clear the headers\n                this.load(headers['FEN'], true);\n            }\n        }\n        /*\n         * NB: the regexes below that delete move numbers, recursive annotations,\n         * and numeric annotation glyphs may also match text in comments. To\n         * prevent this, we transform comments by hex-encoding them in place and\n         * decoding them again after the other tokens have been deleted.\n         *\n         * While the spec states that PGN files should be ASCII encoded, we use\n         * {en,de}codeURIComponent here to support arbitrary UTF8 as a convenience\n         * for modern users\n         */\n        function toHex(s) {\n            return Array.from(s)\n                .map(function (c) {\n                /*\n                 * encodeURI doesn't transform most ASCII characters, so we handle\n                 * these ourselves\n                 */\n                return c.charCodeAt(0) < 128\n                    ? c.charCodeAt(0).toString(16)\n                    : encodeURIComponent(c).replace(/%/g, '').toLowerCase();\n            })\n                .join('');\n        }\n        function fromHex(s) {\n            return s.length == 0\n                ? ''\n                : decodeURIComponent('%' + (s.match(/.{1,2}/g) || []).join('%'));\n        }\n        const encodeComment = function (s) {\n            s = s.replace(new RegExp(mask(newlineChar), 'g'), ' ');\n            return `{${toHex(s.slice(1, s.length - 1))}}`;\n        };\n        const decodeComment = function (s) {\n            if (s.startsWith('{') && s.endsWith('}')) {\n                return fromHex(s.slice(1, s.length - 1));\n            }\n        };\n        // delete header to get the moves\n        let ms = pgn\n            .replace(headerString, '')\n            .replace(\n        // encode comments so they don't get deleted below\n        new RegExp(`({[^}]*})+?|;([^${mask(newlineChar)}]*)`, 'g'), function (_match, bracket, semicolon) {\n            return bracket !== undefined\n                ? encodeComment(bracket)\n                : ' ' + encodeComment(`{${semicolon.slice(1)}}`);\n        })\n            .replace(new RegExp(mask(newlineChar), 'g'), ' ');\n        // delete recursive annotation variations\n        const ravRegex = /(\\([^()]+\\))+?/g;\n        while (ravRegex.test(ms)) {\n            ms = ms.replace(ravRegex, '');\n        }\n        // delete move numbers\n        ms = ms.replace(/\\d+\\.(\\.\\.)?/g, '');\n        // delete ... indicating black to move\n        ms = ms.replace(/\\.\\.\\./g, '');\n        /* delete numeric annotation glyphs */\n        ms = ms.replace(/\\$\\d+/g, '');\n        // trim and get array of moves\n        let moves = ms.trim().split(new RegExp(/\\s+/));\n        // delete empty entries\n        moves = moves.filter((move) => move !== '');\n        let result = '';\n        for (let halfMove = 0; halfMove < moves.length; halfMove++) {\n            const comment = decodeComment(moves[halfMove]);\n            if (comment !== undefined) {\n                this._comments[this.fen()] = comment;\n                continue;\n            }\n            const move = this._moveFromSan(moves[halfMove], strict);\n            // invalid move\n            if (move == null) {\n                // was the move an end of game marker\n                if (TERMINATION_MARKERS.indexOf(moves[halfMove]) > -1) {\n                    result = moves[halfMove];\n                }\n                else {\n                    throw new Error(`Invalid move in PGN: ${moves[halfMove]}`);\n                }\n            }\n            else {\n                // reset the end of game marker if making a valid move\n                result = '';\n                this._makeMove(move);\n            }\n        }\n        /*\n         * Per section 8.2.6 of the PGN spec, the Result tag pair must match match\n         * the termination marker. Only do this when headers are present, but the\n         * result tag is missing\n         */\n        if (result && Object.keys(this._header).length && !this._header['Result']) {\n            this.header('Result', result);\n        }\n    }\n    /*\n     * Convert a move from 0x88 coordinates to Standard Algebraic Notation\n     * (SAN)\n     *\n     * @param {boolean} strict Use the strict SAN parser. It will throw errors\n     * on overly disambiguated moves (see below):\n     *\n     * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\n     * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\n     * 4. ... Ne7 is technically the valid SAN\n     */\n    _moveToSan(move, moves) {\n        let output = '';\n        if (move.flags & BITS.KSIDE_CASTLE) {\n            output = 'O-O';\n        }\n        else if (move.flags & BITS.QSIDE_CASTLE) {\n            output = 'O-O-O';\n        }\n        else {\n            if (move.piece !== PAWN) {\n                const disambiguator = getDisambiguator(move, moves);\n                output += move.piece.toUpperCase() + disambiguator;\n            }\n            if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n                if (move.piece === PAWN) {\n                    output += algebraic(move.from)[0];\n                }\n                output += 'x';\n            }\n            output += algebraic(move.to);\n            if (move.promotion) {\n                output += '=' + move.promotion.toUpperCase();\n            }\n        }\n        this._makeMove(move);\n        if (this.isCheck()) {\n            if (this.isCheckmate()) {\n                output += '#';\n            }\n            else {\n                output += '+';\n            }\n        }\n        this._undoMove();\n        return output;\n    }\n    // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\n    _moveFromSan(move, strict = false) {\n        // strip off any move decorations: e.g Nf3+?! becomes Nf3\n        const cleanMove = strippedSan(move);\n        let pieceType = inferPieceType(cleanMove);\n        let moves = this._moves({ legal: true, piece: pieceType });\n        // strict parser\n        for (let i = 0, len = moves.length; i < len; i++) {\n            if (cleanMove === strippedSan(this._moveToSan(moves[i], moves))) {\n                return moves[i];\n            }\n        }\n        // the strict parser failed\n        if (strict) {\n            return null;\n        }\n        let piece = undefined;\n        let matches = undefined;\n        let from = undefined;\n        let to = undefined;\n        let promotion = undefined;\n        /*\n         * The default permissive (non-strict) parser allows the user to parse\n         * non-standard chess notations. This parser is only run after the strict\n         * Standard Algebraic Notation (SAN) parser has failed.\n         *\n         * When running the permissive parser, we'll run a regex to grab the piece, the\n         * to/from square, and an optional promotion piece. This regex will\n         * parse common non-standard notation like: Pe2-e4, Rc1c4, Qf3xf7,\n         * f7f8q, b1c3\n         *\n         * NOTE: Some positions and moves may be ambiguous when using the permissive\n         * parser. For example, in this position: 6k1/8/8/B7/8/8/8/BN4K1 w - - 0 1,\n         * the move b1c3 may be interpreted as Nc3 or B1c3 (a disambiguated bishop\n         * move). In these cases, the permissive parser will default to the most\n         * basic interpretation (which is b1c3 parsing to Nc3).\n         */\n        let overlyDisambiguated = false;\n        matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/\n        //     piece         from              to       promotion\n        );\n        if (matches) {\n            piece = matches[1];\n            from = matches[2];\n            to = matches[3];\n            promotion = matches[4];\n            if (from.length == 1) {\n                overlyDisambiguated = true;\n            }\n        }\n        else {\n            /*\n             * The [a-h]?[1-8]? portion of the regex below handles moves that may be\n             * overly disambiguated (e.g. Nge7 is unnecessary and non-standard when\n             * there is one legal knight move to e7). In this case, the value of\n             * 'from' variable will be a rank or file, not a square.\n             */\n            matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/);\n            if (matches) {\n                piece = matches[1];\n                from = matches[2];\n                to = matches[3];\n                promotion = matches[4];\n                if (from.length == 1) {\n                    overlyDisambiguated = true;\n                }\n            }\n        }\n        pieceType = inferPieceType(cleanMove);\n        moves = this._moves({\n            legal: true,\n            piece: piece ? piece : pieceType,\n        });\n        for (let i = 0, len = moves.length; i < len; i++) {\n            if (from && to) {\n                // hand-compare move properties with the results from our permissive regex\n                if ((!piece || piece.toLowerCase() == moves[i].piece) &&\n                    Ox88[from] == moves[i].from &&\n                    Ox88[to] == moves[i].to &&\n                    (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n                    return moves[i];\n                }\n                else if (overlyDisambiguated) {\n                    /*\n                     * SPECIAL CASE: we parsed a move string that may have an unneeded\n                     * rank/file disambiguator (e.g. Nge7).  The 'from' variable will\n                     */\n                    const square = algebraic(moves[i].from);\n                    if ((!piece || piece.toLowerCase() == moves[i].piece) &&\n                        Ox88[to] == moves[i].to &&\n                        (from == square[0] || from == square[1]) &&\n                        (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n                        return moves[i];\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    ascii() {\n        let s = '   +------------------------+\\n';\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            // display the rank\n            if (file(i) === 0) {\n                s += ' ' + '87654321'[rank(i)] + ' |';\n            }\n            if (this._board[i]) {\n                const piece = this._board[i].type;\n                const color = this._board[i].color;\n                const symbol = color === WHITE ? piece.toUpperCase() : piece.toLowerCase();\n                s += ' ' + symbol + ' ';\n            }\n            else {\n                s += ' . ';\n            }\n            if ((i + 1) & 0x88) {\n                s += '|\\n';\n                i += 8;\n            }\n        }\n        s += '   +------------------------+\\n';\n        s += '     a  b  c  d  e  f  g  h';\n        return s;\n    }\n    perft(depth) {\n        const moves = this._moves({ legal: false });\n        let nodes = 0;\n        const color = this._turn;\n        for (let i = 0, len = moves.length; i < len; i++) {\n            this._makeMove(moves[i]);\n            if (!this._isKingAttacked(color)) {\n                if (depth - 1 > 0) {\n                    nodes += this.perft(depth - 1);\n                }\n                else {\n                    nodes++;\n                }\n            }\n            this._undoMove();\n        }\n        return nodes;\n    }\n    // pretty = external move object\n    _makePretty(uglyMove) {\n        const { color, piece, from, to, flags, captured, promotion } = uglyMove;\n        let prettyFlags = '';\n        for (const flag in BITS) {\n            if (BITS[flag] & flags) {\n                prettyFlags += FLAGS[flag];\n            }\n        }\n        const fromAlgebraic = algebraic(from);\n        const toAlgebraic = algebraic(to);\n        const move = {\n            color,\n            piece,\n            from: fromAlgebraic,\n            to: toAlgebraic,\n            san: this._moveToSan(uglyMove, this._moves({ legal: true })),\n            flags: prettyFlags,\n            lan: fromAlgebraic + toAlgebraic,\n            before: this.fen(),\n            after: '',\n        };\n        // generate the FEN for the 'after' key\n        this._makeMove(uglyMove);\n        move.after = this.fen();\n        this._undoMove();\n        if (captured) {\n            move.captured = captured;\n        }\n        if (promotion) {\n            move.promotion = promotion;\n            move.lan += promotion;\n        }\n        return move;\n    }\n    turn() {\n        return this._turn;\n    }\n    board() {\n        const output = [];\n        let row = [];\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            if (this._board[i] == null) {\n                row.push(null);\n            }\n            else {\n                row.push({\n                    square: algebraic(i),\n                    type: this._board[i].type,\n                    color: this._board[i].color,\n                });\n            }\n            if ((i + 1) & 0x88) {\n                output.push(row);\n                row = [];\n                i += 8;\n            }\n        }\n        return output;\n    }\n    squareColor(square) {\n        if (square in Ox88) {\n            const sq = Ox88[square];\n            return (rank(sq) + file(sq)) % 2 === 0 ? 'light' : 'dark';\n        }\n        return null;\n    }\n    history({ verbose = false } = {}) {\n        const reversedHistory = [];\n        const moveHistory = [];\n        while (this._history.length > 0) {\n            reversedHistory.push(this._undoMove());\n        }\n        while (true) {\n            const move = reversedHistory.pop();\n            if (!move) {\n                break;\n            }\n            if (verbose) {\n                moveHistory.push(this._makePretty(move));\n            }\n            else {\n                moveHistory.push(this._moveToSan(move, this._moves()));\n            }\n            this._makeMove(move);\n        }\n        return moveHistory;\n    }\n    _pruneComments() {\n        const reversedHistory = [];\n        const currentComments = {};\n        const copyComment = (fen) => {\n            if (fen in this._comments) {\n                currentComments[fen] = this._comments[fen];\n            }\n        };\n        while (this._history.length > 0) {\n            reversedHistory.push(this._undoMove());\n        }\n        copyComment(this.fen());\n        while (true) {\n            const move = reversedHistory.pop();\n            if (!move) {\n                break;\n            }\n            this._makeMove(move);\n            copyComment(this.fen());\n        }\n        this._comments = currentComments;\n    }\n    getComment() {\n        return this._comments[this.fen()];\n    }\n    setComment(comment) {\n        this._comments[this.fen()] = comment.replace('{', '[').replace('}', ']');\n    }\n    deleteComment() {\n        const comment = this._comments[this.fen()];\n        delete this._comments[this.fen()];\n        return comment;\n    }\n    getComments() {\n        this._pruneComments();\n        return Object.keys(this._comments).map((fen) => {\n            return { fen: fen, comment: this._comments[fen] };\n        });\n    }\n    deleteComments() {\n        this._pruneComments();\n        return Object.keys(this._comments).map((fen) => {\n            const comment = this._comments[fen];\n            delete this._comments[fen];\n            return { fen: fen, comment: comment };\n        });\n    }\n}\n//# sourceMappingURL=chess.js.map","<script>\n  import { writable } from \"svelte/store\";\n  import { Chess } from \"chess.js\";\n  import { onMount, afterUpdate } from 'svelte';\n\n  let chess = new Chess();\n\n  export let history = [];\n  export let handleMove;\n  export let handleUndo;\n  export let handleRedo;\n  export let currentIndex;\n  \n  function displayMove(move,index) { \n    if (index % 2 == 0) {\n      return parseInt(index/2)+1 + \". \" + move.san;\n    }\n    else{\n      return move.san;\n    }\n  }\n  let moveRefs = [];\n\n  onMount(() => {\n    window.addEventListener('keydown', handleGlobalKeyDown);\n\n    scrollToSelectedMove();\n  });\n\n  afterUpdate(() => {\n    window.removeEventListener('keydown', handleGlobalKeyDown);\n\n    scrollToSelectedMove();\n  });\n\n  function handleGlobalKeyDown(event) {\n    if (event.key === 'ArrowLeft') {\n      handleUndo();\n    }\n    if (event.key === 'ArrowRight') {\n      handleRedo();\n    }\n  }\n\n  function scrollToSelectedMove() {\n    if (moveRefs[currentIndex]) {\n      moveRefs[currentIndex].scrollIntoView({\n        behavior: 'smooth',\n        block: 'center',\n        inline: 'nearest',\n      });\n    }\n  }\n  \n</script>\n\n<style>\n  .move-list {\n    display: grid;\n    grid-template-columns: repeat(2, 1fr);\n    gap: 8px;\n    width: 100%;\n    max-width: 180px;\n    max-height: 370px;\n    overflow-y: auto;\n    padding: 8px;\n    border: 1px solid #ccc;\n    background-color: #f8f8f8;\n  }\n\n  \n  .almost-invisible {\n    background-color: rgba(255, 255, 255, 0.1); /* adjust opacity as needed */\n    border: 1px solid rgba(255, 255, 255, 0.2); /* adjust opacity as needed */\n    padding: 5px 10px;\n    font-size: 14px;\n    cursor: pointer;\n  }\n  .almost-invisible-on {\n    background-color: #e8e8e8;\n    border: 1px solid rgba(255, 255, 255, 0.2); /* adjust opacity as needed */\n    padding: 5px 10px;\n    font-size: 14px;\n    cursor: pointer;\n  }\n  .almost-invisible:hover {\n    background-color: #e8e8e8;\n  }\n\n</style>\n\n<div>\n  {#if history != []}\n    <div class=\"move-list\">\n      {#each history as move, index}\n          {#if index == currentIndex}\n            <button bind:this={moveRefs[index]} class=\"almost-invisible-on\" on:click={() => { handleMove(index, history); scrollToSelectedMove(); }}>{displayMove(move, index)} </button>\n          {:else}\n            <button bind:this={moveRefs[index]} class=\"almost-invisible\" on:click={() => { handleMove(index, history); scrollToSelectedMove(); }}>{displayMove(move, index)} </button>\n          {/if}\n      {/each}\n    </div>\n  {/if}\n  <button on:click={handleUndo}> prev </button>\n  <button on:click={handleRedo}> next</button>\n</div>\n","<script>\n  export let name = '_';\n\n  const images = {\n    'k': 'https://upload.wikimedia.org/wikipedia/commons/f/f0/Chess_kdt45.svg',\n    'q': 'https://upload.wikimedia.org/wikipedia/commons/4/47/Chess_qdt45.svg',\n    'r': 'https://upload.wikimedia.org/wikipedia/commons/f/ff/Chess_rdt45.svg',\n    'b': 'https://upload.wikimedia.org/wikipedia/commons/9/98/Chess_bdt45.svg',\n    'n': 'https://upload.wikimedia.org/wikipedia/commons/e/ef/Chess_ndt45.svg',\n    'p': 'https://upload.wikimedia.org/wikipedia/commons/c/c7/Chess_pdt45.svg',\n    'K': 'https://upload.wikimedia.org/wikipedia/commons/4/42/Chess_klt45.svg',\n    'Q': 'https://upload.wikimedia.org/wikipedia/commons/1/15/Chess_qlt45.svg',\n    'R': 'https://upload.wikimedia.org/wikipedia/commons/7/72/Chess_rlt45.svg',\n    'B': 'https://upload.wikimedia.org/wikipedia/commons/b/b1/Chess_blt45.svg',\n    'N': 'https://upload.wikimedia.org/wikipedia/commons/7/70/Chess_nlt45.svg',\n    'P': 'https://upload.wikimedia.org/wikipedia/commons/4/45/Chess_plt45.svg',\n    '_': 'https://upload.wikimedia.org/wikipedia/commons/1/1d/No_image.svg'\n  }\n\n  // Compute the image URL directly from the `name` prop\n  $: image_url = images[name];\n</script>\n\n<div class=\"piece\">\n  <img src={image_url} alt={name} />\n</div>\n\n<style>\n  .piece img {\n    width: 100%;\n    height: 100%;\n  }\n</style>\n","<script>\n    import MoveViewer from \"./MoveViewer.svelte\";\n    import Piece from './Piece.svelte'\n    import {Chess} from \"chess.js\";\n    import { writable } from \"svelte/store\";\n    import { onMount, onDestroy } from 'svelte';\n    import { flip } from \"svelte/animate\";\n\n\n\n    export let startingPositionFEN = \"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1\";\n    export let pgn = \"\";\n    export let debug = false;\n\n    let fen = \"\";\n    let key = 0;\n    let currentIndex = 0;\n    let board = writable(fenToBoard(startingPositionFEN));\n    let history = [];\n    let boardValue;\n    board.subscribe(value => {\n        boardValue = value;\n    });\n    \n   \n    let chess = new Chess();\n\n    let letters = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\"];\n    let numbers = [8, 7, 6, 5, 4, 3, 2, 1];\n\n    \n    \n    function validateFEN(fen) {\n        const fenParts = fen.split(\" \");\n        if (fenParts.length !== 6) {\n          return false;\n      }\n\n      const [position, activeColor, castling, enPassant, halfMove, fullMove] = fenParts;\n\n      // Check position\n      const rows = position.split(\"/\");\n      if (rows.length !== 8) {\n        return false;\n      }\n\n      for (const row of rows) {\n        let rowCount = 0;\n        for (const char of row) {\n          if (isNaN(parseInt(char))) {\n            if (!\"prnbqkPRNBQK\".includes(char)) {\n              return false;\n            }\n            rowCount += 1;\n          } else {\n            rowCount += parseInt(char);\n          }\n        }\n        if (rowCount !== 8) {\n          return false;\n        }\n      }\n\n      // Check active color\n      if (![\"w\", \"b\"].includes(activeColor)) {\n        return false;\n      }\n\n      // Check castling availability\n      if (!/^(KQ?k?q?|Qk?q?|kq?|q|-)$/.test(castling)) {\n        return false;\n      }\n\n      // Check en passant target square\n      if (!/^(?:(?:[a-h][36])|-)$/.test(enPassant)) {\n        return false;\n      }\n\n      // Check halfmove clock and fullmove number\n      if (isNaN(halfMove) || isNaN(fullMove)) {\n        return false;\n      }\n\n      return true;\n    }\n\n  /**\n   * Loads a PGN string and updates the board with the resulting position.\n   */\n    function loadFEN() {\n      if (validateFEN(fen)) {\n        chess.load(fen);\n        board.set(fenToBoard(fen));\n        console.log(board);\n        console.log(boardValue);\n\n        key += 1;\n      } else {\n        console.error(\"Invalid FEN:\", fen);\n      }\n    }\n\n\n  /**\n   * Parses a PGN string into an array of moves.\n   * @param {string} pgn - The PGN string.\n   * @returns {Array<string>} An array of moves.\n   */\n  function loadPGN() {\n    chess.loadPgn(pgn); // Load the PGN using chess.js\n    history = chess.history({ verbose: true }); // Get the move history\n    currentIndex = history.length; // Set the current index to the end of the history\n    console.log(history)\n    updateBoard(history); // Update the board using the move history\n  \n  }\n\n  /**\n   * Converts a FEN string to a 2D array representing the board.\n   * @param {string} fen - The FEN string.\n   * @returns {Array<Array<string>>} A 2D array representing the board.\n   */\n  function fenToBoard(fen) {\n    const [position] = fen.split(\" \");\n    const rows = position.split(\"/\");\n    const board = rows.map((row) => {\n        const newRow = [];\n        for (const char of row) {\n        if (isNaN(parseInt(char))) {\n            newRow.push(char);\n        } else {\n            newRow.push(...Array(parseInt(char)).fill('_'));\n        }\n        }\n        return newRow;\n    });\n    return board;\n  }\n\n  function handleMove(moveIndex, history) {\n    // Reset the chess object to the initial position\n    chess.reset();\n\n    // Apply each move in the history array up to moveIndex (exclusive)\n    for (let i = 0; i < moveIndex; i++) {\n      const move = history[i];\n      const result = chess.move(move);\n      if (!result) {\n        console.error(\"Invalid move:\", move);\n        break;\n      }\n    }\n    currentIndex = moveIndex;\n\n    // Update the board's position based on the chess object's FEN\n    board.set(fenToBoard(chess.fen()));\n  }\n\n  function handleUndo() {\n    currentIndex -= 1;\n    if (currentIndex < 0) {\n      currentIndex = 0;\n    }\n    handleMove(currentIndex, history);\n  }\n\n  function handleRedo() {\n    currentIndex += 1;\n    if (currentIndex > history.length) {\n      currentIndex = history.length;\n    }\n    handleMove(currentIndex, history);\n  }\n\n  function handleGlobalKeyDown(event) {\n    if (event.key === 'ArrowLeft') {\n      handleUndo();\n    }\n    if (event.key === 'ArrowRight') {\n      handleRedo();\n    }\n  }\n\n\n\n  onMount(() => {\n    window.addEventListener('keydown', handleGlobalKeyDown);\n    loadPGN(pgn);\n  });\n  onDestroy(() => {\n    window.removeEventListener('keydown', handleGlobalKeyDown);\n  });\n\n  /**\n   * Updates the board position based on an array of moves.\n   * @param {Array<string>} moves - An array of moves to apply.\n   */\n\n   function updateBoard(moves) {\n    // Reset the chess object to the initial position\n    chess.reset();\n\n    if (!Array.isArray(moves)) {\n      console.error(\"Invalid moves array:\", moves);\n      return;\n    }\n\n    // Apply each move in the moves array\n    for (const move of moves) {\n      const result = chess.move(move);\n      if (!result) {\n        console.error(\"Invalid move:\", move);\n        break;\n      }\n    }\n\n    // Update the board's position based on the chess object's FEN\n    const newFen = chess.fen();\n    board.set(fenToBoard(newFen));\n  }\n\n  \n  $: {\n    boardValue = $board;\n  }\n</script>\n  \n<style>\n  .board {\n    display: grid;\n    grid-template-columns: repeat(8, 1fr);\n    grid-template-rows: repeat(8, 1fr);\n    width: 400px;\n    height: 400px;\n    border: 1px solid black;\n  }\n  .chess-container {\n\t  display: flex;\n\t  justify-content: center;\n\t  align-items: flex-start;\n\t}\n  .cell {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    width: 100%;\n    height: 100%;\n    min-width: 48px;\n    min-height: 48px;\n    max-width: 48px;\n    max-height: 48px;\n    border: 1px solid black;\n  }\n  .board-wrapper {\n    margin-right: 16px; /* Adjust this value to set the spacing between the board and the move viewer */\n  }\n  .black {\n    background-color: #b58863;\n  }\n\n  .white {\n    background-color: #f0d9b5;\n  }\n</style>\n  \n{#if debug}\n  <input bind:value={fen} placeholder=\"Enter FEN\" />\n  <button on:click={loadFEN}>Load FEN</button>\n    \n\n  <input bind:value={pgn} placeholder=\"Enter PGN\" />\n  <button on:click={loadPGN}>Load PGN</button>\n{/if}\n\n<div class=\"chess-container\">\n<div class=\"board-wrapper\">\n  <div class=\"board\">\n    {#each numbers as number, row}\n      {#each letters as letter, col}\n        <div\n          class=\"cell {col % 2 === row % 2 ? 'white' : 'black'}\"\n          data-coordinate=\"{letter}{number}\"\n          key=\"{letter}{number}{boardValue[row][col]}\"\n          transition:flip={{ duration: 1000 }} \n        >\n      <Piece name={boardValue[row][col]}/>\n        </div>\n\n      {/each}\n    {/each}\n  </div>\n</div>\n<MoveViewer {history} {handleMove} {handleUndo} {handleRedo} {currentIndex}/>\n\n</div>\n","import Board from './Board.svelte';\n\n// Re-export the default export with a new name\nexport const PgnReader = Board;\n\n\nexport { default as Board } from './Board.svelte';\n"],"names":["noop","run","fn","current_component","set_current_component","component","get_current_component","Error","onMount","$$","on_mount","push","ATTR_REGEX","CONTENT_REGEX","escape","value","is_attr","str","String","pattern","lastIndex","escaped","last","test","i","ch","substring","each","items","length","validate_component","name","$$render","on_destroy","create_ssr_component","result","props","bindings","slots","context","parent_component","Map","before_update","after_update","callbacks","Object","create","html","render","$$slots","title","head","css","Set","forEach","code","Array","from","map","join","add_attribute","boolean","subscriber_queue","WHITE","BLACK","PAWN","BISHOP","KING","DEFAULT_POSITION","EMPTY","FLAGS","NORMAL","CAPTURE","BIG_PAWN","EP_CAPTURE","PROMOTION","KSIDE_CASTLE","QSIDE_CASTLE","BITS","Ox88","a8","b8","c8","d8","e8","f8","g8","h8","a7","b7","c7","d7","e7","f7","g7","h7","a6","b6","c6","d6","e6","f6","g6","h6","a5","b5","c5","d5","e5","f5","g5","h5","a4","b4","c4","d4","e4","f4","g4","h4","a3","b3","c3","d3","e3","f3","g3","h3","a2","b2","c2","d2","e2","f2","g2","h2","a1","b1","c1","d1","e1","f1","g1","h1","PAWN_OFFSETS","b","w","PIECE_OFFSETS","n","r","q","k","ATTACKS","RAYS","PIECE_MASKS","p","PROMOTIONS","RANK_1","RANK_8","ROOKS","square","flag","SECOND_RANK","TERMINATION_MARKERS","rank","file","isDigit","c","indexOf","algebraic","f","swapColor","color","addMove","moves","to","piece","captured","undefined","flags","promotion","inferPieceType","san","pieceType","charAt","match","toLowerCase","strippedSan","move","replace","Chess","constructor","fen","this","_board","_turn","_header","_kings","_epSquare","_halfMoves","_moveNumber","_history","_comments","_castling","load","clear","keepHeaders","_updateSetup","tokens","split","adjustments","concat","slice","ok","error","moveNumber","parseInt","isNaN","halfMoves","rows","sumFields","previousWasNumber","kings","regex","validateFen","position","put","type","_a","_b","empty","toUpperCase","castling","epSquare","bigPawnSquare","squares","_makeMove","isLegal","_isKingAttacked","_undoMove","reset","get","sq","remove","_attacked","difference","index","offset","j","blocked","isAttacked","attackedBy","isCheck","inCheck","isCheckmate","_moves","isStalemate","isInsufficientMaterial","pieces","bishops","numPieces","squareColor","sum","len","isThreefoldRepetition","positions","repetition","pop","isDraw","isGameOver","verbose","_makePretty","_moveToSan","legal","forSquare","forPiece","us","them","firstSquare","lastSquare","singleSquare","castlingFrom","castlingTo","legalMoves","strict","moveObj","_moveFromSan","JSON","stringify","prettyMove","_push","turn","undo","old","pgn","newline","maxWidth","headerExists","appendComment","moveString","comment","reversedHistory","prefix","Result","strip","wrapComment","width","token","currentWidth","includes","header","args","loadPgn","newlineChar","mask","trim","headerRegexResults","RegExp","exec","headerString","headers","headerObj","key","parsePgnHeader","encodeComment","s","charCodeAt","toString","encodeURIComponent","toHex","decodeComment","startsWith","endsWith","decodeURIComponent","fromHex","ms","_match","bracket","semicolon","ravRegex","filter","halfMove","keys","output","disambiguator","ambiguities","sameRank","sameFile","ambigFrom","ambigTo","getDisambiguator","cleanMove","matches","overlyDisambiguated","ascii","perft","depth","nodes","uglyMove","prettyFlags","fromAlgebraic","toAlgebraic","lan","before","after","board","row","history","moveHistory","_pruneComments","currentComments","copyComment","getComment","setComment","deleteComment","getComments","deleteComments","displayMove","$$props","handleMove","handleUndo","handleRedo","currentIndex","moveRefs","handleGlobalKeyDown","event","scrollToSelectedMove","scrollIntoView","behavior","block","inline","window","addEventListener","removeEventListener","image_url","K","Q","R","B","N","P","_","fenToBoard","newRow","char","fill","startingPositionFEN","debug","start","stop","subscribers","set","new_value","a","run_queue","subscriber","update","subscribe","invalidate","add","size","delete","writable","store","unsub","unsubscribe","boardValue","chess","letters","loadPGN","console","log","isArray","newFen","updateBoard","moveIndex","$board","number","letter","col","Piece","$$result","PgnReader","Board"],"mappings":"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AAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAC3D,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAChD,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAChD,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAChD,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAChD,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAChD,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAChD,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAG1CC,EAAO,CACT,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAChD,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAChD,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAChD,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAChD,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAChD,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAChD,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAChD,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,EACpD,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,IAAK,IAAK,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EACnD,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EACnD,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,GAAI,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EACnD,EAAG,EAAG,GAAI,GAAI,EAAG,EAAG,GAAI,GAAI,EAAG,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,EACnD,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,EAAG,EACnD,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,GAClD,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,IAE7CC,EAAc,CAAEC,EAAG,EAAKP,EAAG,EAAKH,EAAG,EAAKI,EAAG,EAAKC,EAAG,GAAMC,EAAG,IAE5DK,EAAa,CAvIG,IAuIM1F,EArIR,IACC,KAqIf2F,EAAS,EASTC,EAAS,EACTC,EAAQ,CACVb,EAAG,CACC,CAAEc,OAAQjF,EAAKyD,GAAIyB,KAAMnF,EAAKD,cAC9B,CAAEmF,OAAQjF,EAAKgE,GAAIkB,KAAMnF,EAAKF,eAElCqE,EAAG,CACC,CAAEe,OAAQjF,EAAKC,GAAIiF,KAAMnF,EAAKD,cAC9B,CAAEmF,OAAQjF,EAAKQ,GAAI0E,KAAMnF,EAAKF,gBAGhCsF,EAAc,CAAEjB,EAZP,EAYkBC,EAnBlB,GAoBTiB,EAAsB,CAAC,MAAO,MAAO,UAAW,KAEtD,SAASC,EAAKJ,GACV,OAAOA,GAAU,CACrB,CAEA,SAASK,EAAKL,GACV,OAAgB,GAATA,CACX,CACA,SAASM,EAAQC,GACb,OAAoC,IAA7B,aAAaC,QAAQD,EAChC,CAEA,SAASE,EAAUT,GACf,MAAMU,EAAIL,EAAKL,GACTX,EAAIe,EAAKJ,GACf,MAAQ,WAAWtI,UAAUgJ,EAAGA,EAAI,GAChC,WAAWhJ,UAAU2H,EAAGA,EAAI,EACpC,CACA,SAASsB,EAAUC,GACf,OAAOA,IAAU7G,EAAQC,EAAQD,CACrC,CAkJA,SAAS8G,EAAQC,EAAOF,EAAOnH,EAAMsH,EAAIC,EAAOC,EAAWC,UAAWC,EAAQrG,EAAKP,QAC/E,MAAM8E,EAAIe,EAAKW,GACf,GAAIC,IAAU/G,GAASoF,IAAMQ,GAAUR,IAAMS,EAezCgB,EAAMnK,KAAK,CACPiK,QACAnH,OACAsH,KACAC,QACAC,WACAE,eApBJ,IAAK,IAAI3J,EAAI,EAAGA,EAAIoI,EAAW/H,OAAQL,IAAK,CACxC,MAAM4J,EAAYxB,EAAWpI,GAC7BsJ,EAAMnK,KAAK,CACPiK,QACAnH,OACAsH,KACAC,QACAC,WACAG,YACAD,MAAOA,EAAQrG,EAAKH,WAE3B,CAYT,CACA,SAAS0G,EAAeC,GACpB,IAAIC,EAAYD,EAAIE,OAAO,GAC3B,GAAID,GAAa,KAAOA,GAAa,IAAK,CAEtC,GADgBD,EAAIG,MAAM,oBAEtB,OAEJ,OAAOxH,CACV,CAED,OADAsH,EAAYA,EAAUG,cACJ,MAAdH,EACOpH,EAEJoH,CACX,CAEA,SAASI,EAAYC,GACjB,OAAOA,EAAKC,QAAQ,IAAK,IAAIA,QAAQ,cAAe,GACxD,CACO,MAAMC,EACTC,YAAYC,EAAM5H,GACd6H,KAAKC,OAAS,IAAI1I,MAAM,KACxByI,KAAKE,MAAQpI,EACbkI,KAAKG,QAAU,GACfH,KAAKI,OAAS,CAAEnD,EAAG7E,EAAO4E,EAAG5E,GAC7B4H,KAAKK,WAAa,EAClBL,KAAKM,WAAa,EAClBN,KAAKO,YAAc,EACnBP,KAAKQ,SAAW,GAChBR,KAAKS,UAAY,GACjBT,KAAKU,UAAY,CAAEzD,EAAG,EAAGD,EAAG,GAC5BgD,KAAKW,KAAKZ,EACb,CACDa,MAAMC,GAAc,GAChBb,KAAKC,OAAS,IAAI1I,MAAM,KACxByI,KAAKI,OAAS,CAAEnD,EAAG7E,EAAO4E,EAAG5E,GAC7B4H,KAAKE,MAAQpI,EACbkI,KAAKU,UAAY,CAAEzD,EAAG,EAAGD,EAAG,GAC5BgD,KAAKK,UAAYjI,EACjB4H,KAAKM,WAAa,EAClBN,KAAKO,YAAc,EACnBP,KAAKQ,SAAW,GAChBR,KAAKS,UAAY,GACjBT,KAAKG,QAAUU,EAAcb,KAAKG,QAAU,CAAA,EAC5CH,KAAKc,aAAad,KAAKD,MAC1B,CACDY,KAAKZ,EAAKc,GAAc,GACpB,IAAIE,EAAShB,EAAIiB,MAAM,OAEvB,GAAID,EAAOnL,QAAU,GAAKmL,EAAOnL,OAAS,EAAG,CACzC,MAAMqL,EAAc,CAAC,IAAK,IAAK,IAAK,KACpClB,EAAMgB,EAAOG,OAAOD,EAAYE,QAAQ,EAAIJ,EAAOnL,UAAU8B,KAAK,IACrE,CACDqJ,EAAShB,EAAIiB,MAAM,OACnB,MAAMI,GAAEA,EAAEC,MAAEA,GAlOb,SAAqBtB,GAExB,MAAMgB,EAAShB,EAAIiB,MAAM,OACzB,GAAsB,IAAlBD,EAAOnL,OACP,MAAO,CACHwL,IAAI,EACJC,MAAO,wDAIf,MAAMC,EAAaC,SAASR,EAAO,GAAI,IACvC,GAAIS,MAAMF,IAAeA,GAAc,EACnC,MAAO,CACHF,IAAI,EACJC,MAAO,uDAIf,MAAMI,EAAYF,SAASR,EAAO,GAAI,IACtC,GAAIS,MAAMC,IAAcA,EAAY,EAChC,MAAO,CACHL,IAAI,EACJC,MAAO,wEAIf,IAAK,uBAAuB/L,KAAKyL,EAAO,IACpC,MAAO,CAAEK,IAAI,EAAOC,MAAO,6CAG/B,GAAI,WAAW/L,KAAKyL,EAAO,IACvB,MAAO,CAAEK,IAAI,EAAOC,MAAO,iDAG/B,IAAK,UAAU/L,KAAKyL,EAAO,IACvB,MAAO,CAAEK,IAAI,EAAOC,MAAO,wCAG/B,MAAMK,EAAOX,EAAO,GAAGC,MAAM,KAC7B,GAAoB,IAAhBU,EAAK9L,OACL,MAAO,CACHwL,IAAI,EACJC,MAAO,iEAIf,IAAK,IAAI9L,EAAI,EAAGA,EAAImM,EAAK9L,OAAQL,IAAK,CAElC,IAAIoM,EAAY,EACZC,GAAoB,EACxB,IAAK,IAAItE,EAAI,EAAGA,EAAIoE,EAAKnM,GAAGK,OAAQ0H,IAChC,GAAIe,EAAQqD,EAAKnM,GAAG+H,IAAK,CACrB,GAAIsE,EACA,MAAO,CACHR,IAAI,EACJC,MAAO,2DAGfM,GAAaJ,SAASG,EAAKnM,GAAG+H,GAAI,IAClCsE,GAAoB,CACvB,KACI,CACD,IAAK,mBAAmBtM,KAAKoM,EAAKnM,GAAG+H,IACjC,MAAO,CACH8D,IAAI,EACJC,MAAO,sDAGfM,GAAa,EACbC,GAAoB,CACvB,CAEL,GAAkB,IAAdD,EACA,MAAO,CACHP,IAAI,EACJC,MAAO,gEAGlB,CACD,GAAqB,KAAhBN,EAAO,GAAG,IAA0B,KAAbA,EAAO,IACd,KAAhBA,EAAO,GAAG,IAA0B,KAAbA,EAAO,GAC/B,MAAO,CAAEK,IAAI,EAAOC,MAAO,0CAE/B,MAAMQ,EAAQ,CACV,CAAElD,MAAO,QAASmD,MAAO,MACzB,CAAEnD,MAAO,QAASmD,MAAO,OAE7B,IAAK,MAAMnD,MAAEA,EAAKmD,MAAEA,KAAWD,EAAO,CAClC,IAAKC,EAAMxM,KAAKyL,EAAO,IACnB,MAAO,CAAEK,IAAI,EAAOC,MAAO,wBAAwB1C,UAEvD,IAAKoC,EAAO,GAAGvB,MAAMsC,IAAU,IAAIlM,OAAS,EACxC,MAAO,CAAEwL,IAAI,EAAOC,MAAO,yBAAyB1C,UAE3D,CACD,MAAO,CAAEyC,IAAI,EACjB,CAkI8BW,CAAYhC,GAClC,IAAKqB,EACD,MAAM,IAAI9M,MAAM+M,GAEpB,MAAMW,EAAWjB,EAAO,GACxB,IAAIhD,EAAS,EACbiC,KAAKY,MAAMC,GACX,IAAK,IAAItL,EAAI,EAAGA,EAAIyM,EAASpM,OAAQL,IAAK,CACtC,MAAMwJ,EAAQiD,EAASzC,OAAOhK,GAC9B,GAAc,MAAVwJ,EACAhB,GAAU,OAET,GAAIM,EAAQU,GACbhB,GAAUwD,SAASxC,EAAO,QAEzB,CACD,MAAMJ,EAAQI,EAAQ,IAAMjH,EAAQC,EACpCiI,KAAKiC,IAAI,CAAEC,KAAMnD,EAAMU,cAAed,SAASH,EAAUT,IACzDA,GACH,CACJ,CACDiC,KAAKE,MAAQa,EAAO,GAChBA,EAAO,GAAGxC,QAAQ,MAAQ,IAC1ByB,KAAKU,UAAUzD,GAAKpE,EAAKF,cAEzBoI,EAAO,GAAGxC,QAAQ,MAAQ,IAC1ByB,KAAKU,UAAUzD,GAAKpE,EAAKD,cAEzBmI,EAAO,GAAGxC,QAAQ,MAAQ,IAC1ByB,KAAKU,UAAU1D,GAAKnE,EAAKF,cAEzBoI,EAAO,GAAGxC,QAAQ,MAAQ,IAC1ByB,KAAKU,UAAU1D,GAAKnE,EAAKD,cAE7BoH,KAAKK,UAA0B,MAAdU,EAAO,GAAa3I,EAAQU,EAAKiI,EAAO,IACzDf,KAAKM,WAAaiB,SAASR,EAAO,GAAI,IACtCf,KAAKO,YAAcgB,SAASR,EAAO,GAAI,IACvCf,KAAKc,aAAad,KAAKD,MAC1B,CACDA,MACI,IAAIoC,EAAIC,EACR,IAAIC,EAAQ,EACRtC,EAAM,GACV,IAAK,IAAIxK,EAAIuD,EAAKC,GAAIxD,GAAKuD,EAAKgE,GAAIvH,IAAK,CACrC,GAAIyK,KAAKC,OAAO1K,GAAI,CACZ8M,EAAQ,IACRtC,GAAOsC,EACPA,EAAQ,GAEZ,MAAM1D,MAAEA,EAAOuD,KAAMnD,GAAUiB,KAAKC,OAAO1K,GAC3CwK,GAAOpB,IAAU7G,EAAQiH,EAAMuD,cAAgBvD,EAAMU,aACxD,MAEG4C,IAEC9M,EAAI,EAAK,MACN8M,EAAQ,IACRtC,GAAOsC,GAEP9M,IAAMuD,EAAKgE,KACXiD,GAAO,KAEXsC,EAAQ,EACR9M,GAAK,EAEZ,CACD,IAAIgN,EAAW,GACXvC,KAAKU,UAAU5I,GAASe,EAAKF,eAC7B4J,GAAY,KAEZvC,KAAKU,UAAU5I,GAASe,EAAKD,eAC7B2J,GAAY,KAEZvC,KAAKU,UAAU3I,GAASc,EAAKF,eAC7B4J,GAAY,KAEZvC,KAAKU,UAAU3I,GAASc,EAAKD,eAC7B2J,GAAY,KAGhBA,EAAWA,GAAY,IACvB,IAAIC,EAAW,IAKf,GAAIxC,KAAKK,YAAcjI,EAAO,CAC1B,MAAMqK,EAAgBzC,KAAKK,WAAaL,KAAKE,QAAUpI,EAAQ,IAAM,IAC/D4K,EAAU,CAACD,EAAgB,EAAGA,EAAgB,GACpD,IAAK,MAAM1E,KAAU2E,EAAS,CAE1B,GAAa,IAAT3E,EACA,SAEJ,MAAMY,EAAQqB,KAAKE,MAEnB,IAAoC,QAA9BiC,EAAKnC,KAAKC,OAAOlC,UAA4B,IAAPoE,OAAgB,EAASA,EAAGxD,SAAWA,IAC/C,QAA9ByD,EAAKpC,KAAKC,OAAOlC,UAA4B,IAAPqE,OAAgB,EAASA,EAAGF,QAAUlK,EAAM,CAEpFgI,KAAK2C,UAAU,CACXhE,QACAnH,KAAMuG,EACNe,GAAIkB,KAAKK,UACTtB,MAAO/G,EACPgH,SAAUhH,EACVkH,MAAOrG,EAAKJ,aAEhB,MAAMmK,GAAW5C,KAAK6C,gBAAgBlE,GAGtC,GAFAqB,KAAK8C,YAEDF,EAAS,CACTJ,EAAWhE,EAAUwB,KAAKK,WAC1B,KACH,CACJ,CACJ,CACJ,CACD,MAAO,CACHN,EACAC,KAAKE,MACLqC,EACAC,EACAxC,KAAKM,WACLN,KAAKO,aACP7I,KAAK,IACV,CAODoJ,aAAaf,GACLC,KAAKQ,SAAS5K,OAAS,IAEvBmK,IAAQ5H,GACR6H,KAAKG,QAAe,MAAI,IACxBH,KAAKG,QAAa,IAAIJ,WAGfC,KAAKG,QAAe,aACpBH,KAAKG,QAAa,KAEhC,CACD4C,QACI/C,KAAKW,KAAKxI,EACb,CACD6K,IAAIjF,GACA,OAAOiC,KAAKC,OAAOnH,EAAKiF,MAAY,CACvC,CACDkE,KAAIC,KAAEA,EAAIvD,MAAEA,GAASZ,GAEjB,IAA6C,IAvarC,eAuaIQ,QAAQ2D,EAAKzC,eACrB,OAAO,EAGX,KAAM1B,KAAUjF,GACZ,OAAO,EAEX,MAAMmK,EAAKnK,EAAKiF,GAEhB,OAAImE,GAAQhK,GACN8H,KAAKI,OAAOzB,IAAUvG,GAAS4H,KAAKI,OAAOzB,IAAUsE,KAG3DjD,KAAKC,OAAOgD,GAAM,CAAEf,KAAMA,EAAMvD,MAAOA,GACnCuD,IAAShK,IACT8H,KAAKI,OAAOzB,GAASsE,GAEzBjD,KAAKc,aAAad,KAAKD,QAChB,EACV,CACDmD,OAAOnF,GACH,MAAMgB,EAAQiB,KAAKgD,IAAIjF,GAMvB,cALOiC,KAAKC,OAAOnH,EAAKiF,IACpBgB,GAASA,EAAMmD,OAAShK,IACxB8H,KAAKI,OAAOrB,EAAMJ,OAASvG,GAE/B4H,KAAKc,aAAad,KAAKD,OAChBhB,CACV,CACDoE,UAAUxE,EAAOZ,GACb,IAAK,IAAIxI,EAAIuD,EAAKC,GAAIxD,GAAKuD,EAAKgE,GAAIvH,IAAK,CAErC,GAAQ,IAAJA,EAAU,CACVA,GAAK,EACL,QACH,CAED,QAAuB0J,IAAnBe,KAAKC,OAAO1K,IAAoByK,KAAKC,OAAO1K,GAAGoJ,QAAUA,EACzD,SAEJ,MAAMI,EAAQiB,KAAKC,OAAO1K,GACpB6N,EAAa7N,EAAIwI,EAEvB,GAAmB,IAAfqF,EACA,SAEJ,MAAMC,EAAQD,EAAa,IAC3B,GAAI7F,EAAQ8F,GAAS5F,EAAYsB,EAAMmD,MAAO,CAC1C,GAAInD,EAAMmD,OAASlK,EAAM,CACrB,GAAIoL,EAAa,GACb,GAAIrE,EAAMJ,QAAU7G,EAChB,OAAO,OAGX,GAAIiH,EAAMJ,QAAU5G,EAChB,OAAO,EAEf,QACH,CAED,GAAmB,MAAfgH,EAAMmD,MAA+B,MAAfnD,EAAMmD,KAC5B,OAAO,EACX,MAAMoB,EAAS9F,EAAK6F,GACpB,IAAIE,EAAIhO,EAAI+N,EACRE,GAAU,EACd,KAAOD,IAAMxF,GAAQ,CACjB,GAAsB,MAAlBiC,KAAKC,OAAOsD,GAAY,CACxBC,GAAU,EACV,KACH,CACDD,GAAKD,CACR,CACD,IAAKE,EACD,OAAO,CACd,CACJ,CACD,OAAO,CACV,CACDX,gBAAgBlE,GACZ,OAAOqB,KAAKmD,UAAUzE,EAAUC,GAAQqB,KAAKI,OAAOzB,GACvD,CACD8E,WAAW1F,EAAQ2F,GACf,OAAO1D,KAAKmD,UAAUO,EAAY5K,EAAKiF,GAC1C,CACD4F,UACI,OAAO3D,KAAK6C,gBAAgB7C,KAAKE,MACpC,CACD0D,UACI,OAAO5D,KAAK2D,SACf,CACDE,cACI,OAAO7D,KAAK2D,WAAsC,IAAzB3D,KAAK8D,SAASlO,MAC1C,CACDmO,cACI,OAAQ/D,KAAK2D,WAAsC,IAAzB3D,KAAK8D,SAASlO,MAC3C,CACDoO,yBAQI,MAAMC,EAAS,CACXjH,EAAG,EACHG,EAAG,EACHC,EAAG,EACHC,EAAG,EACHC,EAAG,EACHI,EAAG,GAEDwG,EAAU,GAChB,IAAIC,EAAY,EACZC,EAAc,EAClB,IAAK,IAAI7O,EAAIuD,EAAKC,GAAIxD,GAAKuD,EAAKgE,GAAIvH,IAAK,CAErC,GADA6O,GAAeA,EAAc,GAAK,EAC1B,IAAJ7O,EAAU,CACVA,GAAK,EACL,QACH,CACD,MAAMwJ,EAAQiB,KAAKC,OAAO1K,GACtBwJ,IACAkF,EAAOlF,EAAMmD,MAAQnD,EAAMmD,QAAQ+B,EAASA,EAAOlF,EAAMmD,MAAQ,EAAI,EACjEnD,EAAMmD,OAASjK,GACfiM,EAAQxP,KAAK0P,GAEjBD,IAEP,CAED,GAAkB,IAAdA,EACA,OAAO,EAEN,GAES,IAAdA,IACwB,IAAnBF,EAAOhM,IAAoC,IAAnBgM,EAAa,GACtC,OAAO,EAEN,GAAIE,IAAcF,EAAOhM,GAAU,EAAG,CAEvC,IAAIoM,EAAM,EACV,MAAMC,EAAMJ,EAAQtO,OACpB,IAAK,IAAIL,EAAI,EAAGA,EAAI+O,EAAK/O,IACrB8O,GAAOH,EAAQ3O,GAEnB,GAAY,IAAR8O,GAAaA,IAAQC,EACrB,OAAO,CAEd,CACD,OAAO,CACV,CACDC,wBACI,MAAM1F,EAAQ,GACR2F,EAAY,CAAA,EAClB,IAAIC,GAAa,EACjB,OAAa,CACT,MAAM9E,EAAOK,KAAK8C,YAClB,IAAKnD,EACD,MACJd,EAAMnK,KAAKiL,EACd,CACD,OAAa,CAKT,MAAMI,EAAMC,KAAKD,MAAMiB,MAAM,KAAKG,MAAM,EAAG,GAAGzJ,KAAK,KAEnD8M,EAAUzE,GAAOA,KAAOyE,EAAYA,EAAUzE,GAAO,EAAI,EACrDyE,EAAUzE,IAAQ,IAClB0E,GAAa,GAEjB,MAAM9E,EAAOd,EAAM6F,MACnB,IAAK/E,EACD,MAGAK,KAAK2C,UAAUhD,EAEtB,CACD,OAAO8E,CACV,CACDE,SACI,OAAQ3E,KAAKM,YAAc,KACvBN,KAAK+D,eACL/D,KAAKgE,0BACLhE,KAAKuE,uBACZ,CACDK,aACI,OAAO5E,KAAK6D,eAAiB7D,KAAK+D,eAAiB/D,KAAK2E,QAC3D,CACD9F,OAAMgG,QAAEA,GAAU,EAAK9G,OAAEA,EAAkBgB,MAAEA,GAAuB,IAChE,MAAMF,EAAQmB,KAAK8D,OAAO,CAAE/F,SAAQgB,UACpC,OAAI8F,EACOhG,EAAMpH,KAAKkI,GAASK,KAAK8E,YAAYnF,KAGrCd,EAAMpH,KAAKkI,GAASK,KAAK+E,WAAWpF,EAAMd,IAExD,CACDiF,QAAOkB,MAAEA,GAAQ,EAAIjG,MAAEA,EAAiBhB,OAAEA,GAAwB,IAC9D,IAAIoE,EACJ,MAAM8C,EAAYlH,EAASA,EAAO0B,mBAAgBR,EAC5CiG,EAAWnG,aAAqC,EAASA,EAAMU,cAC/DZ,EAAQ,GACRsG,EAAKnF,KAAKE,MACVkF,EAAO1G,EAAUyG,GACvB,IAAIE,EAAcvM,EAAKC,GACnBuM,EAAaxM,EAAKgE,GAClByI,GAAe,EAEnB,GAAIN,EAAW,CAEX,KAAMA,KAAanM,GACf,MAAO,GAGPuM,EAAcC,EAAaxM,EAAKmM,GAChCM,GAAe,CAEtB,CACD,IAAK,IAAI/N,EAAO6N,EAAa7N,GAAQ8N,EAAY9N,IAAQ,CAErD,GAAW,IAAPA,EAAa,CACbA,GAAQ,EACR,QACH,CAED,IAAKwI,KAAKC,OAAOzI,IAASwI,KAAKC,OAAOzI,GAAMmH,QAAUyG,EAClD,SAEJ,MAAMlD,KAAEA,GAASlC,KAAKC,OAAOzI,GAC7B,IAAIsH,EACJ,GAAIoD,IAASlK,EAAM,CACf,GAAIkN,GAAYA,IAAahD,EACzB,SAEJpD,EAAKtH,EAAOuF,EAAaoI,GAAI,GACxBnF,KAAKC,OAAOnB,KACbF,EAAQC,EAAOsG,EAAI3N,EAAMsH,EAAI9G,GAE7B8G,EAAKtH,EAAOuF,EAAaoI,GAAI,GACzBlH,EAAYkH,KAAQhH,EAAK3G,IAAUwI,KAAKC,OAAOnB,IAC/CF,EAAQC,EAAOsG,EAAI3N,EAAMsH,EAAI9G,OAAMiH,EAAWpG,EAAKL,WAI3D,IAAK,IAAI+K,EAAI,EAAGA,EAAI,EAAGA,IACnBzE,EAAKtH,EAAOuF,EAAaoI,GAAI5B,GACpB,IAALzE,KAE4B,QAA1BqD,EAAKnC,KAAKC,OAAOnB,UAAwB,IAAPqD,OAAgB,EAASA,EAAGxD,SAAWyG,EAC3ExG,EAAQC,EAAOsG,EAAI3N,EAAMsH,EAAI9G,EAAMgI,KAAKC,OAAOnB,GAAIoD,KAAMrJ,EAAKN,SAEzDuG,IAAOkB,KAAKK,WACjBzB,EAAQC,EAAOsG,EAAI3N,EAAMsH,EAAI9G,EAAMA,EAAMa,EAAKJ,YAGzD,KACI,CACD,GAAIyM,GAAYA,IAAahD,EACzB,SACJ,IAAK,IAAIqB,EAAI,EAAGe,EAAMpH,EAAcgF,GAAMtM,OAAQ2N,EAAIe,EAAKf,IAAK,CAC5D,MAAMD,EAASpG,EAAcgF,GAAMqB,GAEnC,IADAzE,EAAKtH,EAEDsH,GAAMwE,IACG,IAALxE,IAFK,CAIT,GAAKkB,KAAKC,OAAOnB,GAGZ,CAED,GAAIkB,KAAKC,OAAOnB,GAAIH,QAAUwG,EAC1B,MACJvG,EAAQC,EAAOsG,EAAI3N,EAAMsH,EAAIoD,EAAMlC,KAAKC,OAAOnB,GAAIoD,KAAMrJ,EAAKN,SAC9D,KACH,CAED,GAVIqG,EAAQC,EAAOsG,EAAI3N,EAAMsH,EAAIoD,GA7zBnC,MAu0BMA,GAAmBA,IAAShK,EAC5B,KACP,CACJ,CACJ,CACJ,CAMD,UAAiB+G,IAAbiG,GAA0BA,IAAahN,GAClCqN,GAAgBD,IAAetF,KAAKI,OAAO+E,IAAK,CAEjD,GAAInF,KAAKU,UAAUyE,GAAMtM,EAAKF,aAAc,CACxC,MAAM6M,EAAexF,KAAKI,OAAO+E,GAC3BM,EAAaD,EAAe,EAC7BxF,KAAKC,OAAOuF,EAAe,IAC3BxF,KAAKC,OAAOwF,IACZzF,KAAKmD,UAAUiC,EAAMpF,KAAKI,OAAO+E,KACjCnF,KAAKmD,UAAUiC,EAAMI,EAAe,IACpCxF,KAAKmD,UAAUiC,EAAMK,IACtB7G,EAAQC,EAAOsG,EAAInF,KAAKI,OAAO+E,GAAKM,EAAYvN,OAAM+G,EAAWpG,EAAKF,aAE7E,CAED,GAAIqH,KAAKU,UAAUyE,GAAMtM,EAAKD,aAAc,CACxC,MAAM4M,EAAexF,KAAKI,OAAO+E,GAC3BM,EAAaD,EAAe,EAC7BxF,KAAKC,OAAOuF,EAAe,IAC3BxF,KAAKC,OAAOuF,EAAe,IAC3BxF,KAAKC,OAAOuF,EAAe,IAC3BxF,KAAKmD,UAAUiC,EAAMpF,KAAKI,OAAO+E,KACjCnF,KAAKmD,UAAUiC,EAAMI,EAAe,IACpCxF,KAAKmD,UAAUiC,EAAMK,IACtB7G,EAAQC,EAAOsG,EAAInF,KAAKI,OAAO+E,GAAKM,EAAYvN,OAAM+G,EAAWpG,EAAKD,aAE7E,CACJ,CAML,IAAKoM,EACD,OAAOnG,EAGX,MAAM6G,EAAa,GACnB,IAAK,IAAInQ,EAAI,EAAG+O,EAAMzF,EAAMjJ,OAAQL,EAAI+O,EAAK/O,IACzCyK,KAAK2C,UAAU9D,EAAMtJ,IAChByK,KAAK6C,gBAAgBsC,IACtBO,EAAWhR,KAAKmK,EAAMtJ,IAE1ByK,KAAK8C,YAET,OAAO4C,CACV,CACD/F,KAAKA,GAAMgG,OAAEA,GAAS,GAAU,CAAA,GAc5B,IAAIC,EAAU,KACd,GAAoB,iBAATjG,EACPiG,EAAU5F,KAAK6F,aAAalG,EAAMgG,QAEjC,GAAoB,iBAAThG,EAAmB,CAC/B,MAAMd,EAAQmB,KAAK8D,SAEnB,IAAK,IAAIvO,EAAI,EAAG+O,EAAMzF,EAAMjJ,OAAQL,EAAI+O,EAAK/O,IACzC,GAAIoK,EAAKnI,OAASgH,EAAUK,EAAMtJ,GAAGiC,OACjCmI,EAAKb,KAAON,EAAUK,EAAMtJ,GAAGuJ,QAC5B,cAAeD,EAAMtJ,KAAOoK,EAAKR,YAAcN,EAAMtJ,GAAG4J,WAAY,CACvEyG,EAAU/G,EAAMtJ,GAChB,KACH,CAER,CAED,IAAKqQ,EACD,KAAoB,iBAATjG,EACD,IAAIrL,MAAM,iBAAiBqL,KAG3B,IAAIrL,MAAM,iBAAiBwR,KAAKC,UAAUpG,MAOxD,MAAMqG,EAAahG,KAAK8E,YAAYc,GAEpC,OADA5F,KAAK2C,UAAUiD,GACRI,CACV,CACDC,MAAMtG,GACFK,KAAKQ,SAAS9L,KAAK,CACfiL,OACAkC,MAAO,CAAE7E,EAAGgD,KAAKI,OAAOpD,EAAGC,EAAG+C,KAAKI,OAAOnD,GAC1CiJ,KAAMlG,KAAKE,MACXqC,SAAU,CAAEvF,EAAGgD,KAAKU,UAAU1D,EAAGC,EAAG+C,KAAKU,UAAUzD,GACnDuF,SAAUxC,KAAKK,UACfoB,UAAWzB,KAAKM,WAChBgB,WAAYtB,KAAKO,aAExB,CACDoC,UAAUhD,GACN,MAAMwF,EAAKnF,KAAKE,MACVkF,EAAO1G,EAAUyG,GAkBvB,GAjBAnF,KAAKiG,MAAMtG,GACXK,KAAKC,OAAON,EAAKb,IAAMkB,KAAKC,OAAON,EAAKnI,aACjCwI,KAAKC,OAAON,EAAKnI,MAEpBmI,EAAKT,MAAQrG,EAAKJ,aACduH,KAAKE,QAAUnI,SACRiI,KAAKC,OAAON,EAAKb,GAAK,WAGtBkB,KAAKC,OAAON,EAAKb,GAAK,KAIjCa,EAAKR,YACLa,KAAKC,OAAON,EAAKb,IAAM,CAAEoD,KAAMvC,EAAKR,UAAWR,MAAOwG,IAGtDnF,KAAKC,OAAON,EAAKb,IAAIoD,OAAShK,EAAM,CAGpC,GAFA8H,KAAKI,OAAO+E,GAAMxF,EAAKb,GAEnBa,EAAKT,MAAQrG,EAAKF,aAAc,CAChC,MAAM8M,EAAa9F,EAAKb,GAAK,EACvB0G,EAAe7F,EAAKb,GAAK,EAC/BkB,KAAKC,OAAOwF,GAAczF,KAAKC,OAAOuF,UAC/BxF,KAAKC,OAAOuF,EACtB,MACI,GAAI7F,EAAKT,MAAQrG,EAAKD,aAAc,CACrC,MAAM6M,EAAa9F,EAAKb,GAAK,EACvB0G,EAAe7F,EAAKb,GAAK,EAC/BkB,KAAKC,OAAOwF,GAAczF,KAAKC,OAAOuF,UAC/BxF,KAAKC,OAAOuF,EACtB,CAEDxF,KAAKU,UAAUyE,GAAM,CACxB,CAED,GAAInF,KAAKU,UAAUyE,GACf,IAAK,IAAI5P,EAAI,EAAG+O,EAAMxG,EAAMqH,GAAIvP,OAAQL,EAAI+O,EAAK/O,IAC7C,GAAIoK,EAAKnI,OAASsG,EAAMqH,GAAI5P,GAAGwI,QAC3BiC,KAAKU,UAAUyE,GAAMrH,EAAMqH,GAAI5P,GAAGyI,KAAM,CACxCgC,KAAKU,UAAUyE,IAAOrH,EAAMqH,GAAI5P,GAAGyI,KACnC,KACH,CAIT,GAAIgC,KAAKU,UAAU0E,GACf,IAAK,IAAI7P,EAAI,EAAG+O,EAAMxG,EAAMsH,GAAMxP,OAAQL,EAAI+O,EAAK/O,IAC/C,GAAIoK,EAAKb,KAAOhB,EAAMsH,GAAM7P,GAAGwI,QAC3BiC,KAAKU,UAAU0E,GAAQtH,EAAMsH,GAAM7P,GAAGyI,KAAM,CAC5CgC,KAAKU,UAAU0E,IAAStH,EAAMsH,GAAM7P,GAAGyI,KACvC,KACH,CAIL2B,EAAKT,MAAQrG,EAAKL,SAEdwH,KAAKK,UADL8E,IAAOpN,EACU4H,EAAKb,GAAK,GAGVa,EAAKb,GAAK,GAI/BkB,KAAKK,UAAYjI,EAGjBuH,EAAKZ,QAAU/G,GAGV2H,EAAKT,OAASrG,EAAKN,QAAUM,EAAKJ,YAFvCuH,KAAKM,WAAa,EAMlBN,KAAKM,aAEL6E,IAAOpN,GACPiI,KAAKO,cAETP,KAAKE,MAAQkF,CAChB,CACDe,OACI,MAAMxG,EAAOK,KAAK8C,YAClB,OAAOnD,EAAOK,KAAK8E,YAAYnF,GAAQ,IAC1C,CACDmD,YACI,MAAMsD,EAAMpG,KAAKQ,SAASkE,MAC1B,QAAYzF,IAARmH,EACA,OAAO,KAEX,MAAMzG,EAAOyG,EAAIzG,KACjBK,KAAKI,OAASgG,EAAIvE,MAClB7B,KAAKE,MAAQkG,EAAIF,KACjBlG,KAAKU,UAAY0F,EAAI7D,SACrBvC,KAAKK,UAAY+F,EAAI5D,SACrBxC,KAAKM,WAAa8F,EAAI3E,UACtBzB,KAAKO,YAAc6F,EAAI9E,WACvB,MAAM6D,EAAKnF,KAAKE,MACVkF,EAAO1G,EAAUyG,GAIvB,GAHAnF,KAAKC,OAAON,EAAKnI,MAAQwI,KAAKC,OAAON,EAAKb,IAC1CkB,KAAKC,OAAON,EAAKnI,MAAM0K,KAAOvC,EAAKZ,aAC5BiB,KAAKC,OAAON,EAAKb,IACpBa,EAAKX,SACL,GAAIW,EAAKT,MAAQrG,EAAKJ,WAAY,CAE9B,IAAI4K,EAEAA,EADA8B,IAAOpN,EACC4H,EAAKb,GAAK,GAGVa,EAAKb,GAAK,GAEtBkB,KAAKC,OAAOoD,GAAS,CAAEnB,KAAMlK,EAAM2G,MAAOyG,EAC7C,MAGGpF,KAAKC,OAAON,EAAKb,IAAM,CAAEoD,KAAMvC,EAAKX,SAAUL,MAAOyG,GAG7D,GAAIzF,EAAKT,OAASrG,EAAKF,aAAeE,EAAKD,cAAe,CACtD,IAAI6M,EAAYD,EACZ7F,EAAKT,MAAQrG,EAAKF,cAClB8M,EAAa9F,EAAKb,GAAK,EACvB0G,EAAe7F,EAAKb,GAAK,IAGzB2G,EAAa9F,EAAKb,GAAK,EACvB0G,EAAe7F,EAAKb,GAAK,GAE7BkB,KAAKC,OAAOwF,GAAczF,KAAKC,OAAOuF,UAC/BxF,KAAKC,OAAOuF,EACtB,CACD,OAAO7F,CACV,CACD0G,KAAIC,QAAEA,EAAU,KAAIC,SAAEA,EAAW,GAAO,IAKpC,MAAMrQ,EAAS,GACf,IAAIsQ,GAAe,EAEnB,IAAK,MAAMjR,KAAKyK,KAAKG,QAKjBjK,EAAOxB,KAAK,IAAMa,EAAI,KAAOyK,KAAKG,QAAQ5K,GAAK,KAAO+Q,GACtDE,GAAe,EAEfA,GAAgBxG,KAAKQ,SAAS5K,QAC9BM,EAAOxB,KAAK4R,GAEhB,MAAMG,EAAiBC,IACnB,MAAMC,EAAU3G,KAAKS,UAAUT,KAAKD,OACpC,QAAuB,IAAZ4G,EAAyB,CAEhCD,EAAa,GAAGA,IADEA,EAAW9Q,OAAS,EAAI,IAAM,MACN+Q,IAC7C,CACD,OAAOD,CAAU,EAGfE,EAAkB,GACxB,KAAO5G,KAAKQ,SAAS5K,OAAS,GAC1BgR,EAAgBlS,KAAKsL,KAAK8C,aAE9B,MAAMjE,EAAQ,GACd,IAAI6H,EAAa,GAMjB,IAJ+B,IAA3BE,EAAgBhR,QAChBiJ,EAAMnK,KAAK+R,EAAc,KAGtBG,EAAgBhR,OAAS,GAAG,CAC/B8Q,EAAaD,EAAcC,GAC3B,MAAM/G,EAAOiH,EAAgBlC,MAE7B,IAAK/E,EACD,MAGJ,GAAKK,KAAKQ,SAAS5K,QAAyB,MAAf+J,EAAKhB,MAKV,MAAfgB,EAAKhB,QAEN+H,EAAW9Q,QACXiJ,EAAMnK,KAAKgS,GAEfA,EAAa1G,KAAKO,YAAc,SAVa,CAC7C,MAAMsG,EAAS,GAAG7G,KAAKO,mBAEvBmG,EAAaA,EAAa,GAAGA,KAAcG,IAAWA,CACzD,CAQDH,EACIA,EAAa,IAAM1G,KAAK+E,WAAWpF,EAAMK,KAAK8D,OAAO,CAAEkB,OAAO,KAClEhF,KAAK2C,UAAUhD,EAClB,CAaD,GAXI+G,EAAW9Q,QACXiJ,EAAMnK,KAAK+R,EAAcC,SAGM,IAAxB1G,KAAKG,QAAQ2G,QACpBjI,EAAMnK,KAAKsL,KAAKG,QAAQ2G,QAMX,IAAbP,EACA,OAAOrQ,EAAOwB,KAAK,IAAMmH,EAAMnH,KAAK,KAGxC,MAAMqP,EAAQ,WACV,OAAI7Q,EAAON,OAAS,GAAmC,MAA9BM,EAAOA,EAAON,OAAS,KAC5CM,EAAOwO,OACA,EAGvB,EAEcsC,EAAc,SAAUC,EAAOtH,GACjC,IAAK,MAAMuH,KAASvH,EAAKqB,MAAM,KAC3B,GAAKkG,EAAL,CAGA,GAAID,EAAQC,EAAMtR,OAAS2Q,EAAU,CACjC,KAAOQ,KACHE,IAEJ/Q,EAAOxB,KAAK4R,GACZW,EAAQ,CACX,CACD/Q,EAAOxB,KAAKwS,GACZD,GAASC,EAAMtR,OACfM,EAAOxB,KAAK,KACZuS,GAXC,CAgBL,OAHIF,KACAE,IAEGA,CACnB,EAEQ,IAAIE,EAAe,EACnB,IAAK,IAAI5R,EAAI,EAAGA,EAAIsJ,EAAMjJ,OAAQL,IAC1B4R,EAAetI,EAAMtJ,GAAGK,OAAS2Q,GAC7B1H,EAAMtJ,GAAG6R,SAAS,KAClBD,EAAeH,EAAYG,EAActI,EAAMtJ,KAKnD4R,EAAetI,EAAMtJ,GAAGK,OAAS2Q,GAAkB,IAANhR,GAEX,MAA9BW,EAAOA,EAAON,OAAS,IACvBM,EAAOwO,MAEXxO,EAAOxB,KAAK4R,GACZa,EAAe,GAEJ,IAAN5R,IACLW,EAAOxB,KAAK,KACZyS,KAEJjR,EAAOxB,KAAKmK,EAAMtJ,IAClB4R,GAAgBtI,EAAMtJ,GAAGK,QAE7B,OAAOM,EAAOwB,KAAK,GACtB,CACD2P,UAAUC,GACN,IAAK,IAAI/R,EAAI,EAAGA,EAAI+R,EAAK1R,OAAQL,GAAK,EACX,iBAAZ+R,EAAK/R,IAA0C,iBAAhB+R,EAAK/R,EAAI,KAC/CyK,KAAKG,QAAQmH,EAAK/R,IAAM+R,EAAK/R,EAAI,IAGzC,OAAOyK,KAAKG,OACf,CACDoH,QAAQlB,GAAKV,OAAEA,GAAS,EAAK6B,YAAEA,EAAc,SAAa,IACtD,SAASC,EAAKzS,GACV,OAAOA,EAAI4K,QAAQ,MAAO,KAC7B,CAiBDyG,EAAMA,EAAIqB,OAUV,MASMC,EATc,IAAIC,OAAO,YAC3BH,EAAKD,GADsB,oBAI3BC,EAAKD,GACL,eACAC,EAAKD,GACL,QAEmCK,KAAKxB,GACtCyB,EAAeH,GACfA,EAAmB/R,QAAU,EACzB+R,EAAmB,GAEvB,GAEN3H,KAAK+C,QAEL,MAAMgF,EA5CN,SAAwBV,GACpB,MAAMW,EAAY,CAAA,EACZD,EAAUV,EAAOrG,MAAM,IAAI4G,OAAOH,EAAKD,KAC7C,IAAIS,EAAM,GACNnT,EAAQ,GACZ,IAAK,IAAIS,EAAI,EAAGA,EAAIwS,EAAQnS,OAAQL,IAAK,CACrC,MAAMuM,EAAQ,yCACdmG,EAAMF,EAAQxS,GAAGqK,QAAQkC,EAAO,MAChChN,EAAQiT,EAAQxS,GAAGqK,QAAQkC,EAAO,MAC9BmG,EAAIP,OAAO9R,OAAS,IACpBoS,EAAUC,GAAOnT,EAExB,CACD,OAAOkT,CACV,CA8BeE,CAAeJ,GAC/B,IAAI/H,EAAM,GACV,IAAK,MAAMkI,KAAOF,EAEY,QAAtBE,EAAIxI,gBACJM,EAAMgI,EAAQE,IAElBjI,KAAKqH,OAAOY,EAAKF,EAAQE,IAM7B,GAAKtC,GAUD,GAAyB,MAArBoC,EAAe,MAAW,CAC1B,KAAM,QAASA,GACX,MAAM,IAAIzT,MAAM,wDAGpB0L,KAAKW,KAAKoH,EAAa,KAAG,EAC7B,OAfGhI,GACAC,KAAKW,KAAKZ,GAAK,GA4CvB,MAAMoI,EAAgB,SAAUC,GAE5B,MAAO,IApBX,SAAeA,GACX,OAAO7Q,MAAMC,KAAK4Q,GACb3Q,KAAI,SAAU6G,GAKf,OAAOA,EAAE+J,WAAW,GAAK,IACnB/J,EAAE+J,WAAW,GAAGC,SAAS,IACzBC,mBAAmBjK,GAAGsB,QAAQ,KAAM,IAAIH,aAC9D,IACiB/H,KAAK,GACb,CAQc8Q,EADXJ,EAAIA,EAAExI,QAAQ,IAAIgI,OAAOH,EAAKD,GAAc,KAAM,MAC/BrG,MAAM,EAAGiH,EAAExS,OAAS,MACnD,EACc6S,EAAgB,SAAUL,GAC5B,GAAIA,EAAEM,WAAW,MAAQN,EAAEO,SAAS,KAChC,OAXR,SAAiBP,GACb,OAAmB,GAAZA,EAAExS,OACH,GACAgT,mBAAmB,KAAOR,EAAE5I,MAAM,YAAc,IAAI9H,KAAK,KAClE,CAOcmR,CAAQT,EAAEjH,MAAM,EAAGiH,EAAExS,OAAS,GAErD,EAEQ,IAAIkT,EAAKzC,EACJzG,QAAQkI,EAAc,IACtBlI,QAEL,IAAIgI,OAAO,mBAAmBH,EAAKD,QAAmB,MAAM,SAAUuB,EAAQC,EAASC,GACnF,YAAmBhK,IAAZ+J,EACDb,EAAca,GACd,IAAMb,EAAc,IAAIc,EAAU9H,MAAM,MAC1D,IACavB,QAAQ,IAAIgI,OAAOH,EAAKD,GAAc,KAAM,KAEjD,MAAM0B,EAAW,kBACjB,KAAOA,EAAS5T,KAAKwT,IACjBA,EAAKA,EAAGlJ,QAAQsJ,EAAU,IAG9BJ,EAAKA,EAAGlJ,QAAQ,gBAAiB,IAEjCkJ,EAAKA,EAAGlJ,QAAQ,UAAW,IAE3BkJ,EAAKA,EAAGlJ,QAAQ,SAAU,IAE1B,IAAIf,EAAQiK,EAAGpB,OAAO1G,MAAM,IAAI4G,OAAO,QAEvC/I,EAAQA,EAAMsK,QAAQxJ,GAAkB,KAATA,IAC/B,IAAIzJ,EAAS,GACb,IAAK,IAAIkT,EAAW,EAAGA,EAAWvK,EAAMjJ,OAAQwT,IAAY,CACxD,MAAMzC,EAAU8B,EAAc5J,EAAMuK,IACpC,QAAgBnK,IAAZ0H,EAAuB,CACvB3G,KAAKS,UAAUT,KAAKD,OAAS4G,EAC7B,QACH,CACD,MAAMhH,EAAOK,KAAK6F,aAAahH,EAAMuK,GAAWzD,GAEhD,GAAY,MAARhG,EAAc,CAEd,KAAIzB,EAAoBK,QAAQM,EAAMuK,KAAc,GAIhD,MAAM,IAAI9U,MAAM,wBAAwBuK,EAAMuK,MAH9ClT,EAAS2I,EAAMuK,EAKtB,MAGGlT,EAAS,GACT8J,KAAK2C,UAAUhD,EAEtB,CAMGzJ,GAAUU,OAAOyS,KAAKrJ,KAAKG,SAASvK,SAAWoK,KAAKG,QAAgB,QACpEH,KAAKqH,OAAO,SAAUnR,EAE7B,CAYD6O,WAAWpF,EAAMd,GACb,IAAIyK,EAAS,GACb,GAAI3J,EAAKT,MAAQrG,EAAKF,aAClB2Q,EAAS,WAER,GAAI3J,EAAKT,MAAQrG,EAAKD,aACvB0Q,EAAS,YAER,CACD,GAAI3J,EAAKZ,QAAU/G,EAAM,CACrB,MAAMuR,EApoCtB,SAA0B5J,EAAMd,GAC5B,MAAMrH,EAAOmI,EAAKnI,KACZsH,EAAKa,EAAKb,GACVC,EAAQY,EAAKZ,MACnB,IAAIyK,EAAc,EACdC,EAAW,EACXC,EAAW,EACf,IAAK,IAAInU,EAAI,EAAG+O,EAAMzF,EAAMjJ,OAAQL,EAAI+O,EAAK/O,IAAK,CAC9C,MAAMoU,EAAY9K,EAAMtJ,GAAGiC,KACrBoS,EAAU/K,EAAMtJ,GAAGuJ,GAMrBC,IALeF,EAAMtJ,GAAGwJ,OAKAvH,IAASmS,GAAa7K,IAAO8K,IACrDJ,IACIrL,EAAK3G,KAAU2G,EAAKwL,IACpBF,IAEArL,EAAK5G,KAAU4G,EAAKuL,IACpBD,IAGX,CACD,OAAIF,EAAc,EACVC,EAAW,GAAKC,EAAW,EAKpBlL,EAAUhH,GAEZkS,EAAW,EAKTlL,EAAUhH,GAAM+H,OAAO,GAIvBf,EAAUhH,GAAM+H,OAAO,GAG/B,EACX,CAslCsCsK,CAAiBlK,EAAMd,GAC7CyK,GAAU3J,EAAKZ,MAAMuD,cAAgBiH,CACxC,CACG5J,EAAKT,OAASrG,EAAKN,QAAUM,EAAKJ,cAC9BkH,EAAKZ,QAAU/G,IACfsR,GAAU9K,EAAUmB,EAAKnI,MAAM,IAEnC8R,GAAU,KAEdA,GAAU9K,EAAUmB,EAAKb,IACrBa,EAAKR,YACLmK,GAAU,IAAM3J,EAAKR,UAAUmD,cAEtC,CAWD,OAVAtC,KAAK2C,UAAUhD,GACXK,KAAK2D,YACD3D,KAAK6D,cACLyF,GAAU,IAGVA,GAAU,KAGlBtJ,KAAK8C,YACEwG,CACV,CAEDzD,aAAalG,EAAMgG,GAAS,GAExB,MAAMmE,EAAYpK,EAAYC,GAC9B,IAYIZ,EACAgL,EACAvS,EACAsH,EACAK,EAhBAG,EAAYF,EAAe0K,GAC3BjL,EAAQmB,KAAK8D,OAAO,CAAEkB,OAAO,EAAMjG,MAAOO,IAE9C,IAAK,IAAI/J,EAAI,EAAG+O,EAAMzF,EAAMjJ,OAAQL,EAAI+O,EAAK/O,IACzC,GAAIuU,IAAcpK,EAAYM,KAAK+E,WAAWlG,EAAMtJ,GAAIsJ,IACpD,OAAOA,EAAMtJ,GAIrB,GAAIoQ,EACA,OAAO,KAuBX,IAAIqE,GAAsB,EAC1BD,EAAUD,EAAUtK,MAAM,8DAGtBuK,GACAhL,EAAQgL,EAAQ,GAChBvS,EAAOuS,EAAQ,GACfjL,EAAKiL,EAAQ,GACb5K,EAAY4K,EAAQ,GACD,GAAfvS,EAAK5B,SACLoU,GAAsB,KAU1BD,EAAUD,EAAUtK,MAAM,gEACtBuK,IACAhL,EAAQgL,EAAQ,GAChBvS,EAAOuS,EAAQ,GACfjL,EAAKiL,EAAQ,GACb5K,EAAY4K,EAAQ,GACD,GAAfvS,EAAK5B,SACLoU,GAAsB,KAIlC1K,EAAYF,EAAe0K,GAC3BjL,EAAQmB,KAAK8D,OAAO,CAChBkB,OAAO,EACPjG,MAAOA,GAAgBO,IAE3B,IAAK,IAAI/J,EAAI,EAAG+O,EAAMzF,EAAMjJ,OAAQL,EAAI+O,EAAK/O,IACzC,GAAIiC,GAAQsH,EAAI,CAEZ,KAAMC,GAASA,EAAMU,eAAiBZ,EAAMtJ,GAAGwJ,OAC3CjG,EAAKtB,IAASqH,EAAMtJ,GAAGiC,MACvBsB,EAAKgG,IAAOD,EAAMtJ,GAAGuJ,IACnBK,GAAaA,EAAUM,eAAiBZ,EAAMtJ,GAAG4J,WACnD,OAAON,EAAMtJ,GAEZ,GAAIyU,EAAqB,CAK1B,MAAMjM,EAASS,EAAUK,EAAMtJ,GAAGiC,MAClC,KAAMuH,GAASA,EAAMU,eAAiBZ,EAAMtJ,GAAGwJ,OAC3CjG,EAAKgG,IAAOD,EAAMtJ,GAAGuJ,IACpBtH,GAAQuG,EAAO,IAAMvG,GAAQuG,EAAO,IACnCoB,GAAaA,EAAUM,eAAiBZ,EAAMtJ,GAAG4J,WACnD,OAAON,EAAMtJ,EAEpB,CACJ,CAEL,OAAO,IACV,CACD0U,QACI,IAAI7B,EAAI,kCACR,IAAK,IAAI7S,EAAIuD,EAAKC,GAAIxD,GAAKuD,EAAKgE,GAAIvH,IAAK,CAKrC,GAHgB,IAAZ6I,EAAK7I,KACL6S,GAAK,IAAM,WAAWjK,EAAK5I,IAAM,MAEjCyK,KAAKC,OAAO1K,GAAI,CAChB,MAAMwJ,EAAQiB,KAAKC,OAAO1K,GAAG2M,KAG7BkG,GAAK,KAFSpI,KAAKC,OAAO1K,GAAGoJ,QACJ7G,EAAQiH,EAAMuD,cAAgBvD,EAAMU,eACzC,GACvB,MAEG2I,GAAK,MAEJ7S,EAAI,EAAK,MACV6S,GAAK,MACL7S,GAAK,EAEZ,CAGD,OAFA6S,GAAK,kCACLA,GAAK,8BACEA,CACV,CACD8B,MAAMC,GACF,MAAMtL,EAAQmB,KAAK8D,OAAO,CAAEkB,OAAO,IACnC,IAAIoF,EAAQ,EACZ,MAAMzL,EAAQqB,KAAKE,MACnB,IAAK,IAAI3K,EAAI,EAAG+O,EAAMzF,EAAMjJ,OAAQL,EAAI+O,EAAK/O,IACzCyK,KAAK2C,UAAU9D,EAAMtJ,IAChByK,KAAK6C,gBAAgBlE,KAClBwL,EAAQ,EAAI,EACZC,GAASpK,KAAKkK,MAAMC,EAAQ,GAG5BC,KAGRpK,KAAK8C,YAET,OAAOsH,CACV,CAEDtF,YAAYuF,GACR,MAAM1L,MAAEA,EAAKI,MAAEA,EAAKvH,KAAEA,EAAIsH,GAAEA,EAAEI,MAAEA,EAAKF,SAAEA,EAAQG,UAAEA,GAAckL,EAC/D,IAAIC,EAAc,GAClB,IAAK,MAAMtM,KAAQnF,EACXA,EAAKmF,GAAQkB,IACboL,GAAejS,EAAM2F,IAG7B,MAAMuM,EAAgB/L,EAAUhH,GAC1BgT,EAAchM,EAAUM,GACxBa,EAAO,CACThB,QACAI,QACAvH,KAAM+S,EACNzL,GAAI0L,EACJnL,IAAKW,KAAK+E,WAAWsF,EAAUrK,KAAK8D,OAAO,CAAEkB,OAAO,KACpD9F,MAAOoL,EACPG,IAAKF,EAAgBC,EACrBE,OAAQ1K,KAAKD,MACb4K,MAAO,IAaX,OAVA3K,KAAK2C,UAAU0H,GACf1K,EAAKgL,MAAQ3K,KAAKD,MAClBC,KAAK8C,YACD9D,IACAW,EAAKX,SAAWA,GAEhBG,IACAQ,EAAKR,UAAYA,EACjBQ,EAAK8K,KAAOtL,GAETQ,CACV,CACDuG,OACI,OAAOlG,KAAKE,KACf,CACD0K,QACI,MAAMtB,EAAS,GACf,IAAIuB,EAAM,GACV,IAAK,IAAItV,EAAIuD,EAAKC,GAAIxD,GAAKuD,EAAKgE,GAAIvH,IACV,MAAlByK,KAAKC,OAAO1K,GACZsV,EAAInW,KAAK,MAGTmW,EAAInW,KAAK,CACLqJ,OAAQS,EAAUjJ,GAClB2M,KAAMlC,KAAKC,OAAO1K,GAAG2M,KACrBvD,MAAOqB,KAAKC,OAAO1K,GAAGoJ,QAGzBpJ,EAAI,EAAK,MACV+T,EAAO5U,KAAKmW,GACZA,EAAM,GACNtV,GAAK,GAGb,OAAO+T,CACV,CACDlF,YAAYrG,GACR,GAAIA,KAAUjF,EAAM,CAChB,MAAMmK,EAAKnK,EAAKiF,GAChB,OAAQI,EAAK8E,GAAM7E,EAAK6E,IAAO,GAAM,EAAI,QAAU,MACtD,CACD,OAAO,IACV,CACD6H,SAAQjG,QAAEA,GAAU,GAAU,CAAA,GAC1B,MAAM+B,EAAkB,GAClBmE,EAAc,GACpB,KAAO/K,KAAKQ,SAAS5K,OAAS,GAC1BgR,EAAgBlS,KAAKsL,KAAK8C,aAE9B,OAAa,CACT,MAAMnD,EAAOiH,EAAgBlC,MAC7B,IAAK/E,EACD,MAEAkF,EACAkG,EAAYrW,KAAKsL,KAAK8E,YAAYnF,IAGlCoL,EAAYrW,KAAKsL,KAAK+E,WAAWpF,EAAMK,KAAK8D,WAEhD9D,KAAK2C,UAAUhD,EAClB,CACD,OAAOoL,CACV,CACDC,iBACI,MAAMpE,EAAkB,GAClBqE,EAAkB,CAAA,EAClBC,EAAenL,IACbA,KAAOC,KAAKS,YACZwK,EAAgBlL,GAAOC,KAAKS,UAAUV,GACzC,EAEL,KAAOC,KAAKQ,SAAS5K,OAAS,GAC1BgR,EAAgBlS,KAAKsL,KAAK8C,aAG9B,IADAoI,EAAYlL,KAAKD,SACJ,CACT,MAAMJ,EAAOiH,EAAgBlC,MAC7B,IAAK/E,EACD,MAEJK,KAAK2C,UAAUhD,GACfuL,EAAYlL,KAAKD,MACpB,CACDC,KAAKS,UAAYwK,CACpB,CACDE,aACI,OAAOnL,KAAKS,UAAUT,KAAKD,MAC9B,CACDqL,WAAWzE,GACP3G,KAAKS,UAAUT,KAAKD,OAAS4G,EAAQ/G,QAAQ,IAAK,KAAKA,QAAQ,IAAK,IACvE,CACDyL,gBACI,MAAM1E,EAAU3G,KAAKS,UAAUT,KAAKD,OAEpC,cADOC,KAAKS,UAAUT,KAAKD,OACpB4G,CACV,CACD2E,cAEI,OADAtL,KAAKgL,iBACEpU,OAAOyS,KAAKrJ,KAAKS,WAAWhJ,KAAKsI,IAC7B,CAAEA,IAAKA,EAAK4G,QAAS3G,KAAKS,UAAUV,MAElD,CACDwL,iBAEI,OADAvL,KAAKgL,iBACEpU,OAAOyS,KAAKrJ,KAAKS,WAAWhJ,KAAKsI,IACpC,MAAM4G,EAAU3G,KAAKS,UAAUV,GAE/B,cADOC,KAAKS,UAAUV,GACf,CAAEA,IAAKA,EAAK4G,QAASA,EAAS,GAE5C,yvICvtDM6E,EAAY7L,EAAK0D,UACpBA,EAAQ,GAAK,EACR9B,SAAS8B,EAAM,GAAG,EAAI,KAAO1D,EAAKN,IAGlCM,EAAKN,+BAbAQ,cAELiL,EAAO,IAAAW,cACPC,GAAUD,cACVE,GAAUF,cACVG,GAAUH,gBACVI,GAAYJ,EAUnBK,EAAQ,GH4mCd,IAAqB7X,EG9lCV,SAAA8X,EAAoBC,GACT,cAAdA,EAAM/D,KACR0D,IAEgB,eAAdK,EAAM/D,KACR2D,aAIKK,IACHH,EAASD,IACXC,EAASD,GAAcK,eAAc,CACnCC,SAAU,SACVC,MAAO,SACPC,OAAQ,mBA1Bd9X,GAAO,KACL+X,OAAOC,iBAAiB,UAAWR,GAEnCE,GAAoB,IHumCHhY,EGpmCR,KACTqY,OAAOE,oBAAoB,UAAWT,GAEtCE,GAAoB,EHkmCpB5X,IAAwBG,GAAGkC,aAAahC,KAAKT,0VGtiC1C6W,GAAO,8CAEDA,GAAO,CAAAnL,EAAA0D,IACL,IAAAA,GAASwI,EACO,qDAAAlU,EAAA,OAAAmU,EAASzI,GAAK,MAAAxO,EAAyG2W,EAAY7L,EAAM0D,gBAEzI,kDAAA1L,EAAA,OAAAmU,EAASzI,GAAK,MAAAxO,EAAsG2W,EAAY7L,EAAM0D,iwDCjGxJvN,KAAAA,EAAO,KAAG2V,EAuBX,mEAJPgB,EAjBS,CACVnP,EAAK,sEACLD,EAAK,sEACLD,EAAK,sEACLJ,EAAK,sEACLG,EAAK,sEACLO,EAAK,sEACLgP,EAAK,sEACLC,EAAK,sEACLC,EAAK,sEACLC,EAAK,sEACLC,EAAK,sEACLC,EAAK,sEACLC,EAAK,oEAIelX,GAIZ,yCAAA6B,EAAA,MAAA8U,eAAgB3W,EAAI,q/RCkGrB,SAAAmX,EAAWlN,GACX,MAAAiC,GAAYjC,EAAIiB,MAAM,YAChBgB,EAAShB,MAAM,KACTvJ,KAAKoT,UACdqC,EAAM,GACD,IAAA,MAAAC,KAAQtC,EACfrJ,MAAMD,SAAS4L,IACfD,EAAOxY,KAAKyY,GAEZD,EAAOxY,QAAQ6C,MAAMgK,SAAS4L,IAAOC,KAAK,aAGvCF,CAAM,oCA5HNG,oBAAAA,EAAsB,4DAA0D5B,GAChFpF,IAAAA,EAAM,IAAEoF,GACR6B,MAAAA,GAAQ,GAAK7B,EAIpBI,EAAe,EACfjB,EJER,SAAkB9V,EAAOyY,EAAQxZ,GAC7B,IAAIyZ,EACJ,MAAMC,EAAc,IAAIrW,IACxB,SAASsW,EAAIC,GACT,GDOmB3Q,ECPO2Q,IDOVC,ECPG9Y,IDQX8Y,EAAI5Q,GAAKA,EAAI4Q,IAAM5Q,GAAO4Q,GAAkB,iBAANA,GAAgC,mBAANA,KCPpE9Y,EAAQ6Y,EACJH,GAAM,CACN,MAAMK,GAAahW,EAAiBjC,OACpC,IAAK,MAAMkY,KAAcL,EACrBK,EAAW,KACXjW,EAAiBnD,KAAKoZ,EAAYhZ,GAEtC,GAAI+Y,EAAW,CACX,IAAK,IAAItY,EAAI,EAAGA,EAAIsC,EAAiBjC,OAAQL,GAAK,EAC9CsC,EAAiBtC,GAAG,GAAGsC,EAAiBtC,EAAI,IAEhDsC,EAAiBjC,OAAS,CAC7B,CACJ,CDPb,IAAwBgY,EAAG5Q,CCStB,CAmBD,MAAO,CAAE0Q,MAAKK,OAlBd,SAAgB9Z,GACZyZ,EAAIzZ,EAAGa,GACV,EAgBqBkZ,UAftB,SAAmBha,EAAKia,EAAala,GACjC,MAAM+Z,EAAa,CAAC9Z,EAAKia,GAMzB,OALAR,EAAYS,IAAIJ,GACS,IAArBL,EAAYU,OACZX,EAAOD,EAAMG,IAAQ3Z,GAEzBC,EAAIc,GACG,KACH2Y,EAAYW,OAAON,GACM,IAArBL,EAAYU,MAAcX,IAC1BA,IACAA,EAAO,KACV,CAER,EAEL,CI1CgBa,CAASpB,EAAWI,MLmCpC,SAAmBiB,KAAU3X,GACzB,GAAa,MAAT2X,EACA,OAAOva,EAEX,MAAMwa,EAAQD,EAAMN,aAAarX,GACjC,OAAO4X,EAAMC,YAAc,IAAMD,EAAMC,cAAgBD,CAC3D,kBKvCQE,EADA3D,EAAO,GAEXF,EAAMoD,WAAUlZ,IACZ2Z,EAAa3Z,CAAK,IAIlB,IAAA4Z,MAAY7O,EAEZ8O,EAAW,CAAA,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,cAiF3CC,IACPF,EAAMnH,QAAQlB,GACdyE,EAAU4D,EAAM5D,QAAU,CAAAjG,SAAS,IACnCgH,EAAef,EAAQlV,OACvBiZ,QAAQC,IAAIhE,GAsFJ,SAAYjM,MAEpB6P,EAAM3L,SAEDxL,MAAMwX,QAAQlQ,eACjBgQ,QAAQxN,MAAM,uBAAwBxC,GAK7B,IAAA,MAAAc,KAAQd,EAAK,KACP6P,EAAM/O,KAAKA,GACf,CACTkP,QAAQxN,MAAM,gBAAiB1B,gBAM7BqP,EAASN,EAAM3O,MACrB6K,EAAM8C,IAAIT,EAAW+B,IAzGrBC,CAAYnE,YA0BLY,EAAWwD,EAAWpE,GAE7B4D,EAAM3L,QAGG,IAAA,IAAAxN,EAAI,EAAGA,EAAI2Z,EAAW3Z,IAAC,OACxBoK,EAAOmL,EAAQvV,OACNmZ,EAAM/O,KAAKA,GACf,CACTkP,QAAQxN,MAAM,gBAAiB1B,UAInCkM,EAAeqD,EAGftE,EAAM8C,IAAIT,EAAWyB,EAAM3O,iBAGpB4L,IACPE,GAAgB,EACZA,EAAe,IACjBA,EAAe,GAEjBH,EAAWG,EAAcf,YAGlBc,IACPC,GAAgB,EACZA,EAAef,EAAQlV,SACzBiW,EAAef,EAAQlV,QAEzB8V,EAAWG,EAAcf,GAGlB,SAAAiB,EAAoBC,GACT,cAAdA,EAAM/D,KACR0D,IAEgB,eAAdK,EAAM/D,KACR2D,ILy9BN,IAAmB3X,SKn9BjBM,GAAO,KACL+X,OAAOC,iBAAiB,UAAWR,GACnC6C,GAAW,ILi9BI3a,EK/8BR,KACPqY,OAAOE,oBAAoB,UAAWT,EAAmB,EL+8BzD1X,IAAwBG,GAAGwB,WAAWtB,KAAKT,0MK96B3Cwa,EAAaU,SA0CZ7B,6CA3PS,GA4PU,uFAIHjH,EAAG,mKAlPL,CAAA,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAyPtB,CAAA+I,EAAAvE,SACL8D,GAAO,CAAAU,EAAAC,IAEG,eAAA,QAAAza,EAAAya,EAAM,GAAMzE,EAAM,EAAI,QAAU,SAC3B,GAAA,sCAAAhW,EAAAwa,GAAQ,GAAAxa,EAAAua,GACpB,YAAAva,EAAAwa,GAAQ,GAAAxa,EAAAua,GAAQ,GAAAva,EAAA4Z,EAAW5D,GAAKyE,IAG7B,OAAAzZ,EAAA0Z,EAAA,SAAAxZ,SAAAyZ,EAAA,CAAA1Z,KAAA2Y,EAAW5D,GAAKyE,IAAG,CAAA,EAAA,CAAA,4JC1RzBG,GAAYC"}